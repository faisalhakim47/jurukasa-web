{"version":3,"file":"bundle01.js","names":["encodeURI","Base64","#output","#isFirst","#key","#array","array","#view","#pos","#reader","#wireType","#expect","#buf","#array","#view","#pos","#ensure","#varint","#tag","#varintBig","#usedIds","#freeIds","freeId","#owner","#sqlId","#closed","#pushStack","#shiftStack","Stmt","Batch","#useCursor","#executed","BatchStep","batch","#conds","#add","BatchCond","#execute","Batch","#client","#stream","#cursorId","#entryQueue","#fetchQueue","#closed","#done","#fetch","entry","#setClosed","#client","#streamId","#queue","#cursor","#closing","#closed","#sendStreamRequest","#pushToQueue","#flushQueue","Stmt","Value","NamedArg","Batch","BatchStep","BatchCond","Base64","ClientMsg","Request","Stmt","Batch","Value","CloseStreamReq","Error","d.string","d.stringOpt","StmtResult","d.arrayObjectsMap","Col","d.array","Value","d.number","BatchResult","d.object","CursorEntry","DescribeResult","DescribeParam","DescribeCol","d.boolean","Base64","ServerMsg","d.string","Error","d.object","d.number","StmtResult","BatchResult","d.arrayObjectsMap","CursorEntry","d.boolean","DescribeResult","Error","Error","WsClient","#socket","#openCallbacks","#opened","#closed","#recvdHello","#subprotocol","#getVersionCalled","#responseMap","#requestIdAlloc","#sqlIdAlloc","#onSocketOpen","#onSocketClose","#onSocketError","#onSocketMessage","#send","#sendToSocket","#setClosed","json_ClientMsg","protobuf_ClientMsg","json_ServerMsg","protobuf_ServerMsg","#handleMsg","#array","#shiftPos","#pushPos","#ensurePush","PipelineRespBody","d.stringOpt","d.arrayObjectsMap","StreamResult","d.string","StreamResponse","d.object","Error","StmtResult","BatchResult","DescribeResult","d.boolean","CursorRespBody","Error","#stream","#encoding","#reader","#queue","#closed","#done","#nextItem","json_CursorRespBody","protobuf_CursorRespBody","json_CursorEntry","protobuf_CursorEntry","#parseItemJson","jsond.readJsonObject","#parseItemProtobuf","protobufd.readProtobufMessage","PipelineReqBody","StreamRequest","Stmt","Batch","CursorReqBody","#client","#baseUrl","#jwt","#fetch","#baton","#queue","#flushing","#closing","#closeQueued","#closed","#sqlIdAlloc","#sendStreamRequest","#pushToQueue","#cursor","#flushQueue","#flushPipeline","#flushCursor","#flush","#createPipelineRequest","#createCursorRequest","fetch","#createRequest","json_PipelineReqBody","protobuf_PipelineReqBody","json_CursorReqBody","protobuf_CursorReqBody","Headers","Request","json_PipelineRespBody","protobuf_PipelineRespBody","HttpClient","#url","#jwt","#fetch","fetch","#closed","#streams","#setClosed","Request","WebSocket","WsClient","HttpClient","#mode","#version","version","#started","batch","hrana.Stmt","hrana.ClientError","hrana.ResponseError","hrana.ProtoError","hrana.ClosedError","hrana.WebSocketError","hrana.HttpServerError","hrana.ProtocolVersionError","hrana.InternalError","#owner","#sqls","#cache","remove","_createClient","hrana.openWs","hrana.WebSocketUnsupportedError","sqlCacheCapacity","#url","#authToken","#intMode","#connState","#openConn","#futureConnState","#promiseLimitFunction","#openStream","version","#client","#streamState","_createClient","#url","#authToken","#intMode","#customFetch","#concurrency","#client","hrana.openHttp","#promiseLimitFunction","version","#stream","#sqlCache","_createWsClient","_createHttpClient","hasOwnProperty","computed","array","self","readonly","effect"],"sources":["../../node_modules/@libsql/core/lib-esm/api.js","../../node_modules/@libsql/core/lib-esm/uri.js","../../node_modules/js-base64/base64.mjs","../../node_modules/@libsql/core/lib-esm/util.js","../../node_modules/@libsql/core/lib-esm/config.js","../../node_modules/@libsql/isomorphic-ws/web.mjs","../../node_modules/@libsql/hrana-client/lib-esm/client.js","../../node_modules/@libsql/hrana-client/lib-esm/errors.js","../../node_modules/@libsql/hrana-client/lib-esm/encoding/json/decode.js","../../node_modules/@libsql/hrana-client/lib-esm/encoding/json/encode.js","../../node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js","../../node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/decode.js","../../node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/encode.js","../../node_modules/@libsql/hrana-client/lib-esm/id_alloc.js","../../node_modules/@libsql/hrana-client/lib-esm/util.js","../../node_modules/@libsql/hrana-client/lib-esm/value.js","../../node_modules/@libsql/hrana-client/lib-esm/result.js","../../node_modules/@libsql/hrana-client/lib-esm/sql.js","../../node_modules/@libsql/hrana-client/lib-esm/queue.js","../../node_modules/@libsql/hrana-client/lib-esm/stmt.js","../../node_modules/@libsql/hrana-client/lib-esm/batch.js","../../node_modules/@libsql/hrana-client/lib-esm/describe.js","../../node_modules/@libsql/hrana-client/lib-esm/stream.js","../../node_modules/@libsql/hrana-client/lib-esm/cursor.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/cursor.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/stream.js","../../node_modules/@libsql/hrana-client/lib-esm/shared/json_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/json_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/shared/json_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/json_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/ws/client.js","../../node_modules/@libsql/isomorphic-fetch/web.js","../../node_modules/@libsql/hrana-client/lib-esm/queue_microtask.js","../../node_modules/@libsql/hrana-client/lib-esm/byte_queue.js","../../node_modules/@libsql/hrana-client/lib-esm/http/json_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/http/protobuf_decode.js","../../node_modules/@libsql/hrana-client/lib-esm/http/cursor.js","../../node_modules/@libsql/hrana-client/lib-esm/http/json_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/http/protobuf_encode.js","../../node_modules/@libsql/hrana-client/lib-esm/http/stream.js","../../node_modules/@libsql/hrana-client/lib-esm/http/client.js","../../node_modules/@libsql/hrana-client/lib-esm/index.js","../../node_modules/@libsql/client/lib-esm/hrana.js","../../node_modules/@libsql/client/lib-esm/sql_cache.js","../../node_modules/promise-limit/index.js","../../node_modules/@libsql/client/lib-esm/ws.js","../../node_modules/@libsql/client/lib-esm/http.js","../../node_modules/@libsql/client/lib-esm/web.js","../../node_modules/@vue/shared/dist/shared.esm-bundler.js","../../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["/** Error thrown by the client. */\nexport class LibsqlError extends Error {\n    /** Machine-readable error code. */\n    code;\n    /** Raw numeric error code */\n    rawCode;\n    constructor(message, code, rawCode, cause) {\n        if (code !== undefined) {\n            message = `${code}: ${message}`;\n        }\n        super(message, { cause });\n        this.code = code;\n        this.rawCode = rawCode;\n        this.name = \"LibsqlError\";\n    }\n}\n","// URI parser based on RFC 3986\n// We can't use the standard `URL` object, because we want to support relative `file:` URLs like\n// `file:relative/path/database.db`, which are not correct according to RFC 8089, which standardizes the\n// `file` scheme.\nimport { LibsqlError } from \"./api.js\";\nexport function parseUri(text) {\n    const match = URI_RE.exec(text);\n    if (match === null) {\n        throw new LibsqlError(`The URL '${text}' is not in a valid format`, \"URL_INVALID\");\n    }\n    const groups = match.groups;\n    const scheme = groups[\"scheme\"];\n    const authority = groups[\"authority\"] !== undefined\n        ? parseAuthority(groups[\"authority\"])\n        : undefined;\n    const path = percentDecode(groups[\"path\"]);\n    const query = groups[\"query\"] !== undefined ? parseQuery(groups[\"query\"]) : undefined;\n    const fragment = groups[\"fragment\"] !== undefined\n        ? percentDecode(groups[\"fragment\"])\n        : undefined;\n    return { scheme, authority, path, query, fragment };\n}\nconst URI_RE = (() => {\n    const SCHEME = \"(?<scheme>[A-Za-z][A-Za-z.+-]*)\";\n    const AUTHORITY = \"(?<authority>[^/?#]*)\";\n    const PATH = \"(?<path>[^?#]*)\";\n    const QUERY = \"(?<query>[^#]*)\";\n    const FRAGMENT = \"(?<fragment>.*)\";\n    return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\\\?${QUERY})?(#${FRAGMENT})?$`, \"su\");\n})();\nfunction parseAuthority(text) {\n    const match = AUTHORITY_RE.exec(text);\n    if (match === null) {\n        throw new LibsqlError(\"The authority part of the URL is not in a valid format\", \"URL_INVALID\");\n    }\n    const groups = match.groups;\n    const host = percentDecode(groups[\"host_br\"] ?? groups[\"host\"]);\n    const port = groups[\"port\"] ? parseInt(groups[\"port\"], 10) : undefined;\n    const userinfo = groups[\"username\"] !== undefined\n        ? {\n            username: percentDecode(groups[\"username\"]),\n            password: groups[\"password\"] !== undefined\n                ? percentDecode(groups[\"password\"])\n                : undefined,\n        }\n        : undefined;\n    return { host, port, userinfo };\n}\nconst AUTHORITY_RE = (() => {\n    return new RegExp(`^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\\\[\\\\]]*)|(\\\\[(?<host_br>[^\\\\[\\\\]]*)\\\\]))(:(?<port>[0-9]*))?$`, \"su\");\n})();\n// Query string is parsed as application/x-www-form-urlencoded according to the Web URL standard:\n// https://url.spec.whatwg.org/#urlencoded-parsing\nfunction parseQuery(text) {\n    const sequences = text.split(\"&\");\n    const pairs = [];\n    for (const sequence of sequences) {\n        if (sequence === \"\") {\n            continue;\n        }\n        let key;\n        let value;\n        const splitIdx = sequence.indexOf(\"=\");\n        if (splitIdx < 0) {\n            key = sequence;\n            value = \"\";\n        }\n        else {\n            key = sequence.substring(0, splitIdx);\n            value = sequence.substring(splitIdx + 1);\n        }\n        pairs.push({\n            key: percentDecode(key.replaceAll(\"+\", \" \")),\n            value: percentDecode(value.replaceAll(\"+\", \" \")),\n        });\n    }\n    return { pairs };\n}\nfunction percentDecode(text) {\n    try {\n        return decodeURIComponent(text);\n    }\n    catch (e) {\n        if (e instanceof URIError) {\n            throw new LibsqlError(`URL component has invalid percent encoding: ${e}`, \"URL_INVALID\", undefined, e);\n        }\n        throw e;\n    }\n}\nexport function encodeBaseUrl(scheme, authority, path) {\n    if (authority === undefined) {\n        throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + \":\")} requires authority (the \"//\" part)`, \"URL_INVALID\");\n    }\n    const schemeText = `${scheme}:`;\n    const hostText = encodeHost(authority.host);\n    const portText = encodePort(authority.port);\n    const userinfoText = encodeUserinfo(authority.userinfo);\n    const authorityText = `//${userinfoText}${hostText}${portText}`;\n    let pathText = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n    if (pathText !== \"\" && !pathText.startsWith(\"/\")) {\n        pathText = \"/\" + pathText;\n    }\n    return new URL(`${schemeText}${authorityText}${pathText}`);\n}\nfunction encodeHost(host) {\n    return host.includes(\":\") ? `[${encodeURI(host)}]` : encodeURI(host);\n}\nfunction encodePort(port) {\n    return port !== undefined ? `:${port}` : \"\";\n}\nfunction encodeUserinfo(userinfo) {\n    if (userinfo === undefined) {\n        return \"\";\n    }\n    const usernameText = encodeURIComponent(userinfo.username);\n    const passwordText = userinfo.password !== undefined\n        ? `:${encodeURIComponent(userinfo.password)}`\n        : \"\";\n    return `${usernameText}${passwordText}@`;\n}\n","/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.8';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, r1, r2;\n    let binArray = []; // use array to avoid minor gc in loop\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        if (r1 === 64) {\n            binArray.push(_fromCC(u24 >> 16 & 255));\n        }\n        else if (r2 === 64) {\n            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));\n        }\n        else {\n            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));\n        }\n    }\n    return binArray.join('');\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n","import { Base64 } from \"js-base64\";\nexport const supportedUrlLink = \"https://github.com/libsql/libsql-client-ts#supported-urls\";\nexport function transactionModeToBegin(mode) {\n    if (mode === \"write\") {\n        return \"BEGIN IMMEDIATE\";\n    }\n    else if (mode === \"read\") {\n        return \"BEGIN TRANSACTION READONLY\";\n    }\n    else if (mode === \"deferred\") {\n        return \"BEGIN DEFERRED\";\n    }\n    else {\n        throw RangeError('Unknown transaction mode, supported values are \"write\", \"read\" and \"deferred\"');\n    }\n}\nexport class ResultSetImpl {\n    columns;\n    columnTypes;\n    rows;\n    rowsAffected;\n    lastInsertRowid;\n    constructor(columns, columnTypes, rows, rowsAffected, lastInsertRowid) {\n        this.columns = columns;\n        this.columnTypes = columnTypes;\n        this.rows = rows;\n        this.rowsAffected = rowsAffected;\n        this.lastInsertRowid = lastInsertRowid;\n    }\n    toJSON() {\n        return {\n            columns: this.columns,\n            columnTypes: this.columnTypes,\n            rows: this.rows.map(rowToJson),\n            rowsAffected: this.rowsAffected,\n            lastInsertRowid: this.lastInsertRowid !== undefined\n                ? \"\" + this.lastInsertRowid\n                : null,\n        };\n    }\n}\nfunction rowToJson(row) {\n    return Array.prototype.map.call(row, valueToJson);\n}\nfunction valueToJson(value) {\n    if (typeof value === \"bigint\") {\n        return \"\" + value;\n    }\n    else if (value instanceof ArrayBuffer) {\n        return Base64.fromUint8Array(new Uint8Array(value));\n    }\n    else {\n        return value;\n    }\n}\n","import { LibsqlError } from \"./api.js\";\nimport { parseUri } from \"./uri.js\";\nimport { supportedUrlLink } from \"./util.js\";\nconst inMemoryMode = \":memory:\";\nexport function isInMemoryConfig(config) {\n    return (config.scheme === \"file\" &&\n        (config.path === \":memory:\" || config.path.startsWith(\":memory:?\")));\n}\nexport function expandConfig(config, preferHttp) {\n    if (typeof config !== \"object\") {\n        // produce a reasonable error message in the common case where users type\n        // `createClient(\"libsql://...\")` instead of `createClient({url: \"libsql://...\"})`\n        throw new TypeError(`Expected client configuration as object, got ${typeof config}`);\n    }\n    let { url, authToken, tls, intMode, concurrency } = config;\n    // fill simple defaults right here\n    concurrency = Math.max(0, concurrency || 20);\n    intMode ??= \"number\";\n    let connectionQueryParams = []; // recognized query parameters which we sanitize through white list of valid key-value pairs\n    // convert plain :memory: url to URI format to make logic more uniform\n    if (url === inMemoryMode) {\n        url = \"file::memory:\";\n    }\n    // parse url parameters first and override config with update values\n    const uri = parseUri(url);\n    const originalUriScheme = uri.scheme.toLowerCase();\n    const isInMemoryMode = originalUriScheme === \"file\" &&\n        uri.path === inMemoryMode &&\n        uri.authority === undefined;\n    let queryParamsDef;\n    if (isInMemoryMode) {\n        queryParamsDef = {\n            cache: {\n                values: [\"shared\", \"private\"],\n                update: (key, value) => connectionQueryParams.push(`${key}=${value}`),\n            },\n        };\n    }\n    else {\n        queryParamsDef = {\n            tls: {\n                values: [\"0\", \"1\"],\n                update: (_, value) => (tls = value === \"1\"),\n            },\n            authToken: {\n                update: (_, value) => (authToken = value),\n            },\n        };\n    }\n    for (const { key, value } of uri.query?.pairs ?? []) {\n        if (!Object.hasOwn(queryParamsDef, key)) {\n            throw new LibsqlError(`Unsupported URL query parameter ${JSON.stringify(key)}`, \"URL_PARAM_NOT_SUPPORTED\");\n        }\n        const queryParamDef = queryParamsDef[key];\n        if (queryParamDef.values !== undefined &&\n            !queryParamDef.values.includes(value)) {\n            throw new LibsqlError(`Unknown value for the \"${key}\" query argument: ${JSON.stringify(value)}. Supported values are: [${queryParamDef.values.map((x) => '\"' + x + '\"').join(\", \")}]`, \"URL_INVALID\");\n        }\n        if (queryParamDef.update !== undefined) {\n            queryParamDef?.update(key, value);\n        }\n    }\n    // fill complex defaults & validate config\n    const connectionQueryParamsString = connectionQueryParams.length === 0\n        ? \"\"\n        : `?${connectionQueryParams.join(\"&\")}`;\n    const path = uri.path + connectionQueryParamsString;\n    let scheme;\n    if (originalUriScheme === \"libsql\") {\n        if (tls === false) {\n            if (uri.authority?.port === undefined) {\n                throw new LibsqlError('A \"libsql:\" URL with ?tls=0 must specify an explicit port', \"URL_INVALID\");\n            }\n            scheme = preferHttp ? \"http\" : \"ws\";\n        }\n        else {\n            scheme = preferHttp ? \"https\" : \"wss\";\n        }\n    }\n    else {\n        scheme = originalUriScheme;\n    }\n    if (scheme === \"http\" || scheme === \"ws\") {\n        tls ??= false;\n    }\n    else {\n        tls ??= true;\n    }\n    if (scheme !== \"http\" &&\n        scheme !== \"ws\" &&\n        scheme !== \"https\" &&\n        scheme !== \"wss\" &&\n        scheme !== \"file\") {\n        throw new LibsqlError('The client supports only \"libsql:\", \"wss:\", \"ws:\", \"https:\", \"http:\" and \"file:\" URLs, ' +\n            `got ${JSON.stringify(uri.scheme + \":\")}. ` +\n            `For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n    }\n    if (intMode !== \"number\" && intMode !== \"bigint\" && intMode !== \"string\") {\n        throw new TypeError(`Invalid value for intMode, expected \"number\", \"bigint\" or \"string\", got ${JSON.stringify(intMode)}`);\n    }\n    if (uri.fragment !== undefined) {\n        throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify(\"#\" + uri.fragment)}`, \"URL_INVALID\");\n    }\n    if (isInMemoryMode) {\n        return {\n            scheme: \"file\",\n            tls: false,\n            path,\n            intMode,\n            concurrency,\n            syncUrl: config.syncUrl,\n            syncInterval: config.syncInterval,\n            readYourWrites: config.readYourWrites,\n            offline: config.offline,\n            fetch: config.fetch,\n            authToken: undefined,\n            encryptionKey: undefined,\n            authority: undefined,\n        };\n    }\n    return {\n        scheme,\n        tls,\n        authority: uri.authority,\n        path,\n        authToken,\n        intMode,\n        concurrency,\n        encryptionKey: config.encryptionKey,\n        syncUrl: config.syncUrl,\n        syncInterval: config.syncInterval,\n        readYourWrites: config.readYourWrites,\n        offline: config.offline,\n        fetch: config.fetch,\n    };\n}\n","let _WebSocket;\nif (typeof WebSocket !== \"undefined\") {\n    _WebSocket = WebSocket;\n} else if (typeof global !== \"undefined\") {\n    _WebSocket = global.WebSocket;\n} else if (typeof window !== \"undefined\") {\n    _WebSocket = window.WebSocket;\n} else if (typeof self !== \"undefined\") {\n    _WebSocket = self.WebSocket;\n}\nexport { _WebSocket as WebSocket };\n","/** A client for the Hrana protocol (a \"database connection pool\"). */\nexport class Client {\n    /** @private */\n    constructor() {\n        this.intMode = \"number\";\n    }\n    /** Representation of integers returned from the database. See {@link IntMode}.\n     *\n     * This value is inherited by {@link Stream} objects created with {@link openStream}, but you can\n     * override the integer mode for every stream by setting {@link Stream.intMode} on the stream.\n     */\n    intMode;\n}\n","/** Generic error produced by the Hrana client. */\nexport class ClientError extends Error {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"ClientError\";\n    }\n}\n/** Error thrown when the server violates the protocol. */\nexport class ProtoError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"ProtoError\";\n    }\n}\n/** Error thrown when the server returns an error response. */\nexport class ResponseError extends ClientError {\n    code;\n    /** @internal */\n    proto;\n    /** @private */\n    constructor(message, protoError) {\n        super(message);\n        this.name = \"ResponseError\";\n        this.code = protoError.code;\n        this.proto = protoError;\n        this.stack = undefined;\n    }\n}\n/** Error thrown when the client or stream is closed. */\nexport class ClosedError extends ClientError {\n    /** @private */\n    constructor(message, cause) {\n        if (cause !== undefined) {\n            super(`${message}: ${cause}`);\n            this.cause = cause;\n        }\n        else {\n            super(message);\n        }\n        this.name = \"ClosedError\";\n    }\n}\n/** Error thrown when the environment does not seem to support WebSockets. */\nexport class WebSocketUnsupportedError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"WebSocketUnsupportedError\";\n    }\n}\n/** Error thrown when we encounter a WebSocket error. */\nexport class WebSocketError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"WebSocketError\";\n    }\n}\n/** Error thrown when the HTTP server returns an error response. */\nexport class HttpServerError extends ClientError {\n    status;\n    /** @private */\n    constructor(message, status) {\n        super(message);\n        this.status = status;\n        this.name = \"HttpServerError\";\n    }\n}\n/** Error thrown when a libsql URL is not valid. */\nexport class LibsqlUrlParseError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"LibsqlUrlParseError\";\n    }\n}\n/** Error thrown when the protocol version is too low to support a feature. */\nexport class ProtocolVersionError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"ProtocolVersionError\";\n    }\n}\n/** Error thrown when an internal client error happens. */\nexport class InternalError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"InternalError\";\n    }\n}\n/** Error thrown when the API is misused. */\nexport class MisuseError extends ClientError {\n    /** @private */\n    constructor(message) {\n        super(message);\n        this.name = \"MisuseError\";\n    }\n}\n","import { ProtoError } from \"../../errors.js\";\nexport function string(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    throw typeError(value, \"string\");\n}\nexport function stringOpt(value) {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    else if (typeof value === \"string\") {\n        return value;\n    }\n    throw typeError(value, \"string or null\");\n}\nexport function number(value) {\n    if (typeof value === \"number\") {\n        return value;\n    }\n    throw typeError(value, \"number\");\n}\nexport function boolean(value) {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    throw typeError(value, \"boolean\");\n}\nexport function array(value) {\n    if (Array.isArray(value)) {\n        return value;\n    }\n    throw typeError(value, \"array\");\n}\nexport function object(value) {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n        return value;\n    }\n    throw typeError(value, \"object\");\n}\nexport function arrayObjectsMap(value, fun) {\n    return array(value).map((elemValue) => fun(object(elemValue)));\n}\nfunction typeError(value, expected) {\n    if (value === undefined) {\n        return new ProtoError(`Expected ${expected}, but the property was missing`);\n    }\n    let received = typeof value;\n    if (value === null) {\n        received = \"null\";\n    }\n    else if (Array.isArray(value)) {\n        received = \"array\";\n    }\n    return new ProtoError(`Expected ${expected}, received ${received}`);\n}\nexport function readJsonObject(value, fun) {\n    return fun(object(value));\n}\n","export class ObjectWriter {\n    #output;\n    #isFirst;\n    constructor(output) {\n        this.#output = output;\n        this.#isFirst = false;\n    }\n    begin() {\n        this.#output.push('{');\n        this.#isFirst = true;\n    }\n    end() {\n        this.#output.push('}');\n        this.#isFirst = false;\n    }\n    #key(name) {\n        if (this.#isFirst) {\n            this.#output.push('\"');\n            this.#isFirst = false;\n        }\n        else {\n            this.#output.push(',\"');\n        }\n        this.#output.push(name);\n        this.#output.push('\":');\n    }\n    string(name, value) {\n        this.#key(name);\n        this.#output.push(JSON.stringify(value));\n    }\n    stringRaw(name, value) {\n        this.#key(name);\n        this.#output.push('\"');\n        this.#output.push(value);\n        this.#output.push('\"');\n    }\n    number(name, value) {\n        this.#key(name);\n        this.#output.push(\"\" + value);\n    }\n    boolean(name, value) {\n        this.#key(name);\n        this.#output.push(value ? \"true\" : \"false\");\n    }\n    object(name, value, valueFun) {\n        this.#key(name);\n        this.begin();\n        valueFun(this, value);\n        this.end();\n    }\n    arrayObjects(name, values, valueFun) {\n        this.#key(name);\n        this.#output.push('[');\n        for (let i = 0; i < values.length; ++i) {\n            if (i !== 0) {\n                this.#output.push(',');\n            }\n            this.begin();\n            valueFun(this, values[i]);\n            this.end();\n        }\n        this.#output.push(']');\n    }\n}\nexport function writeJsonObject(value, fun) {\n    const output = [];\n    const writer = new ObjectWriter(output);\n    writer.begin();\n    fun(writer, value);\n    writer.end();\n    return output.join(\"\");\n}\n","export const VARINT = 0;\nexport const FIXED_64 = 1;\nexport const LENGTH_DELIMITED = 2;\nexport const GROUP_START = 3;\nexport const GROUP_END = 4;\nexport const FIXED_32 = 5;\n","import { ProtoError } from \"../../errors.js\";\nimport { VARINT, FIXED_64, LENGTH_DELIMITED, FIXED_32 } from \"./util.js\";\nclass MessageReader {\n    #array;\n    #view;\n    #pos;\n    constructor(array) {\n        this.#array = array;\n        this.#view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n        this.#pos = 0;\n    }\n    varint() {\n        let value = 0;\n        for (let shift = 0;; shift += 7) {\n            const byte = this.#array[this.#pos++];\n            value |= (byte & 0x7f) << shift;\n            if (!(byte & 0x80)) {\n                break;\n            }\n        }\n        return value;\n    }\n    varintBig() {\n        let value = 0n;\n        for (let shift = 0n;; shift += 7n) {\n            const byte = this.#array[this.#pos++];\n            value |= BigInt(byte & 0x7f) << shift;\n            if (!(byte & 0x80)) {\n                break;\n            }\n        }\n        return value;\n    }\n    bytes(length) {\n        const array = new Uint8Array(this.#array.buffer, this.#array.byteOffset + this.#pos, length);\n        this.#pos += length;\n        return array;\n    }\n    double() {\n        const value = this.#view.getFloat64(this.#pos, true);\n        this.#pos += 8;\n        return value;\n    }\n    skipVarint() {\n        for (;;) {\n            const byte = this.#array[this.#pos++];\n            if (!(byte & 0x80)) {\n                break;\n            }\n        }\n    }\n    skip(count) {\n        this.#pos += count;\n    }\n    eof() {\n        return this.#pos >= this.#array.byteLength;\n    }\n}\nexport class FieldReader {\n    #reader;\n    #wireType;\n    constructor(reader) {\n        this.#reader = reader;\n        this.#wireType = -1;\n    }\n    setup(wireType) {\n        this.#wireType = wireType;\n    }\n    #expect(expectedWireType) {\n        if (this.#wireType !== expectedWireType) {\n            throw new ProtoError(`Expected wire type ${expectedWireType}, got ${this.#wireType}`);\n        }\n        this.#wireType = -1;\n    }\n    bytes() {\n        this.#expect(LENGTH_DELIMITED);\n        const length = this.#reader.varint();\n        return this.#reader.bytes(length);\n    }\n    string() {\n        return new TextDecoder().decode(this.bytes());\n    }\n    message(def) {\n        return readProtobufMessage(this.bytes(), def);\n    }\n    int32() {\n        this.#expect(VARINT);\n        return this.#reader.varint();\n    }\n    uint32() {\n        return this.int32();\n    }\n    bool() {\n        return this.int32() !== 0;\n    }\n    uint64() {\n        this.#expect(VARINT);\n        return this.#reader.varintBig();\n    }\n    sint64() {\n        const value = this.uint64();\n        return (value >> 1n) ^ (-(value & 1n));\n    }\n    double() {\n        this.#expect(FIXED_64);\n        return this.#reader.double();\n    }\n    maybeSkip() {\n        if (this.#wireType < 0) {\n            return;\n        }\n        else if (this.#wireType === VARINT) {\n            this.#reader.skipVarint();\n        }\n        else if (this.#wireType === FIXED_64) {\n            this.#reader.skip(8);\n        }\n        else if (this.#wireType === LENGTH_DELIMITED) {\n            const length = this.#reader.varint();\n            this.#reader.skip(length);\n        }\n        else if (this.#wireType === FIXED_32) {\n            this.#reader.skip(4);\n        }\n        else {\n            throw new ProtoError(`Unexpected wire type ${this.#wireType}`);\n        }\n        this.#wireType = -1;\n    }\n}\nexport function readProtobufMessage(data, def) {\n    const msgReader = new MessageReader(data);\n    const fieldReader = new FieldReader(msgReader);\n    let value = def.default();\n    while (!msgReader.eof()) {\n        const key = msgReader.varint();\n        const tag = key >> 3;\n        const wireType = key & 0x7;\n        fieldReader.setup(wireType);\n        const tagFun = def[tag];\n        if (tagFun !== undefined) {\n            const returnedValue = tagFun(fieldReader, value);\n            if (returnedValue !== undefined) {\n                value = returnedValue;\n            }\n        }\n        fieldReader.maybeSkip();\n    }\n    return value;\n}\n","import { VARINT, FIXED_64, LENGTH_DELIMITED } from \"./util.js\";\nexport class MessageWriter {\n    #buf;\n    #array;\n    #view;\n    #pos;\n    constructor() {\n        this.#buf = new ArrayBuffer(256);\n        this.#array = new Uint8Array(this.#buf);\n        this.#view = new DataView(this.#buf);\n        this.#pos = 0;\n    }\n    #ensure(extra) {\n        if (this.#pos + extra <= this.#buf.byteLength) {\n            return;\n        }\n        let newCap = this.#buf.byteLength;\n        while (newCap < this.#pos + extra) {\n            newCap *= 2;\n        }\n        const newBuf = new ArrayBuffer(newCap);\n        const newArray = new Uint8Array(newBuf);\n        const newView = new DataView(newBuf);\n        newArray.set(new Uint8Array(this.#buf, 0, this.#pos));\n        this.#buf = newBuf;\n        this.#array = newArray;\n        this.#view = newView;\n    }\n    #varint(value) {\n        this.#ensure(5);\n        value = 0 | value;\n        do {\n            let byte = value & 0x7f;\n            value >>>= 7;\n            byte |= (value ? 0x80 : 0);\n            this.#array[this.#pos++] = byte;\n        } while (value);\n    }\n    #varintBig(value) {\n        this.#ensure(10);\n        value = value & 0xffffffffffffffffn;\n        do {\n            let byte = Number(value & 0x7fn);\n            value >>= 7n;\n            byte |= (value ? 0x80 : 0);\n            this.#array[this.#pos++] = byte;\n        } while (value);\n    }\n    #tag(tag, wireType) {\n        this.#varint((tag << 3) | wireType);\n    }\n    bytes(tag, value) {\n        this.#tag(tag, LENGTH_DELIMITED);\n        this.#varint(value.byteLength);\n        this.#ensure(value.byteLength);\n        this.#array.set(value, this.#pos);\n        this.#pos += value.byteLength;\n    }\n    string(tag, value) {\n        this.bytes(tag, new TextEncoder().encode(value));\n    }\n    message(tag, value, fun) {\n        const writer = new MessageWriter();\n        fun(writer, value);\n        this.bytes(tag, writer.data());\n    }\n    int32(tag, value) {\n        this.#tag(tag, VARINT);\n        this.#varint(value);\n    }\n    uint32(tag, value) {\n        this.int32(tag, value);\n    }\n    bool(tag, value) {\n        this.int32(tag, value ? 1 : 0);\n    }\n    sint64(tag, value) {\n        this.#tag(tag, VARINT);\n        this.#varintBig((value << 1n) ^ (value >> 63n));\n    }\n    double(tag, value) {\n        this.#tag(tag, FIXED_64);\n        this.#ensure(8);\n        this.#view.setFloat64(this.#pos, value, true);\n        this.#pos += 8;\n    }\n    data() {\n        return new Uint8Array(this.#buf, 0, this.#pos);\n    }\n}\nexport function writeProtobufMessage(value, fun) {\n    const w = new MessageWriter();\n    fun(w, value);\n    return w.data();\n}\n","import { InternalError } from \"./errors.js\";\n// An allocator of non-negative integer ids.\n//\n// This clever data structure has these \"ideal\" properties:\n// - It consumes memory proportional to the number of used ids (which is optimal).\n// - All operations are O(1) time.\n// - The allocated ids are small (with a slight modification, we could always provide the smallest possible\n// id).\nexport class IdAlloc {\n    // Set of all allocated ids\n    #usedIds;\n    // Set of all free ids lower than `#usedIds.size`\n    #freeIds;\n    constructor() {\n        this.#usedIds = new Set();\n        this.#freeIds = new Set();\n    }\n    // Returns an id that was free, and marks it as used.\n    alloc() {\n        // this \"loop\" is just a way to pick an arbitrary element from the `#freeIds` set\n        for (const freeId of this.#freeIds) {\n            this.#freeIds.delete(freeId);\n            this.#usedIds.add(freeId);\n            // maintain the invariant of `#freeIds`\n            if (!this.#usedIds.has(this.#usedIds.size - 1)) {\n                this.#freeIds.add(this.#usedIds.size - 1);\n            }\n            return freeId;\n        }\n        // the `#freeIds` set is empty, so there are no free ids lower than `#usedIds.size`\n        // this means that `#usedIds` is a set that contains all numbers from 0 to `#usedIds.size - 1`,\n        // so `#usedIds.size` is free\n        const freeId = this.#usedIds.size;\n        this.#usedIds.add(freeId);\n        return freeId;\n    }\n    free(id) {\n        if (!this.#usedIds.delete(id)) {\n            throw new InternalError(\"Freeing an id that is not allocated\");\n        }\n        // maintain the invariant of `#freeIds`\n        this.#freeIds.delete(this.#usedIds.size);\n        if (id < this.#usedIds.size) {\n            this.#freeIds.add(id);\n        }\n    }\n}\n","import { InternalError } from \"./errors.js\";\nexport function impossible(value, message) {\n    throw new InternalError(message);\n}\n","import { ProtoError, MisuseError } from \"./errors.js\";\nimport { impossible } from \"./util.js\";\nexport function valueToProto(value) {\n    if (value === null) {\n        return null;\n    }\n    else if (typeof value === \"string\") {\n        return value;\n    }\n    else if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new RangeError(\"Only finite numbers (not Infinity or NaN) can be passed as arguments\");\n        }\n        return value;\n    }\n    else if (typeof value === \"bigint\") {\n        if (value < minInteger || value > maxInteger) {\n            throw new RangeError(\"This bigint value is too large to be represented as a 64-bit integer and passed as argument\");\n        }\n        return value;\n    }\n    else if (typeof value === \"boolean\") {\n        return value ? 1n : 0n;\n    }\n    else if (value instanceof ArrayBuffer) {\n        return new Uint8Array(value);\n    }\n    else if (value instanceof Uint8Array) {\n        return value;\n    }\n    else if (value instanceof Date) {\n        return +value.valueOf();\n    }\n    else if (typeof value === \"object\") {\n        return \"\" + value.toString();\n    }\n    else {\n        throw new TypeError(\"Unsupported type of value\");\n    }\n}\nconst minInteger = -9223372036854775808n;\nconst maxInteger = 9223372036854775807n;\nexport function valueFromProto(value, intMode) {\n    if (value === null) {\n        return null;\n    }\n    else if (typeof value === \"number\") {\n        return value;\n    }\n    else if (typeof value === \"string\") {\n        return value;\n    }\n    else if (typeof value === \"bigint\") {\n        if (intMode === \"number\") {\n            const num = Number(value);\n            if (!Number.isSafeInteger(num)) {\n                throw new RangeError(\"Received integer which is too large to be safely represented as a JavaScript number\");\n            }\n            return num;\n        }\n        else if (intMode === \"bigint\") {\n            return value;\n        }\n        else if (intMode === \"string\") {\n            return \"\" + value;\n        }\n        else {\n            throw new MisuseError(\"Invalid value for IntMode\");\n        }\n    }\n    else if (value instanceof Uint8Array) {\n        // TODO: we need to copy data from `Uint8Array` to return an `ArrayBuffer`. Perhaps we should add a\n        // `blobMode` parameter, similar to `intMode`, which would allow the user to choose between receiving\n        // `ArrayBuffer` (default, convenient) and `Uint8Array` (zero copy)?\n        return value.slice().buffer;\n    }\n    else if (value === undefined) {\n        throw new ProtoError(\"Received unrecognized type of Value\");\n    }\n    else {\n        throw impossible(value, \"Impossible type of Value\");\n    }\n}\n","import { ResponseError } from \"./errors.js\";\nimport { valueFromProto } from \"./value.js\";\nexport function stmtResultFromProto(result) {\n    return {\n        affectedRowCount: result.affectedRowCount,\n        lastInsertRowid: result.lastInsertRowid,\n        columnNames: result.cols.map(col => col.name),\n        columnDecltypes: result.cols.map(col => col.decltype),\n    };\n}\nexport function rowsResultFromProto(result, intMode) {\n    const stmtResult = stmtResultFromProto(result);\n    const rows = result.rows.map(row => rowFromProto(stmtResult.columnNames, row, intMode));\n    return { ...stmtResult, rows };\n}\nexport function rowResultFromProto(result, intMode) {\n    const stmtResult = stmtResultFromProto(result);\n    let row;\n    if (result.rows.length > 0) {\n        row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);\n    }\n    return { ...stmtResult, row };\n}\nexport function valueResultFromProto(result, intMode) {\n    const stmtResult = stmtResultFromProto(result);\n    let value;\n    if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {\n        value = valueFromProto(result.rows[0][0], intMode);\n    }\n    return { ...stmtResult, value };\n}\nfunction rowFromProto(colNames, values, intMode) {\n    const row = {};\n    // make sure that the \"length\" property is not enumerable\n    Object.defineProperty(row, \"length\", { value: values.length });\n    for (let i = 0; i < values.length; ++i) {\n        const value = valueFromProto(values[i], intMode);\n        Object.defineProperty(row, i, { value });\n        const colName = colNames[i];\n        if (colName !== undefined && !Object.hasOwn(row, colName)) {\n            Object.defineProperty(row, colName, { value, enumerable: true, configurable: true, writable: true });\n        }\n    }\n    return row;\n}\nexport function errorFromProto(error) {\n    return new ResponseError(error.message, error);\n}\n","import { ClientError, ClosedError, MisuseError } from \"./errors.js\";\n/** Text of an SQL statement cached on the server. */\nexport class Sql {\n    #owner;\n    #sqlId;\n    #closed;\n    /** @private */\n    constructor(owner, sqlId) {\n        this.#owner = owner;\n        this.#sqlId = sqlId;\n        this.#closed = undefined;\n    }\n    /** @private */\n    _getSqlId(owner) {\n        if (this.#owner !== owner) {\n            throw new MisuseError(\"Attempted to use SQL text opened with other object\");\n        }\n        else if (this.#closed !== undefined) {\n            throw new ClosedError(\"SQL text is closed\", this.#closed);\n        }\n        return this.#sqlId;\n    }\n    /** Remove the SQL text from the server, releasing resouces. */\n    close() {\n        this._setClosed(new ClientError(\"SQL text was manually closed\"));\n    }\n    /** @private */\n    _setClosed(error) {\n        if (this.#closed === undefined) {\n            this.#closed = error;\n            this.#owner._closeSql(this.#sqlId);\n        }\n    }\n    /** True if the SQL text is closed (removed from the server). */\n    get closed() {\n        return this.#closed !== undefined;\n    }\n}\nexport function sqlToProto(owner, sql) {\n    if (sql instanceof Sql) {\n        return { sqlId: sql._getSqlId(owner) };\n    }\n    else {\n        return { sql: \"\" + sql };\n    }\n}\n","export class Queue {\n    #pushStack;\n    #shiftStack;\n    constructor() {\n        this.#pushStack = [];\n        this.#shiftStack = [];\n    }\n    get length() {\n        return this.#pushStack.length + this.#shiftStack.length;\n    }\n    push(elem) {\n        this.#pushStack.push(elem);\n    }\n    shift() {\n        if (this.#shiftStack.length === 0 && this.#pushStack.length > 0) {\n            this.#shiftStack = this.#pushStack.reverse();\n            this.#pushStack = [];\n        }\n        return this.#shiftStack.pop();\n    }\n    first() {\n        return this.#shiftStack.length !== 0\n            ? this.#shiftStack[this.#shiftStack.length - 1]\n            : this.#pushStack[0];\n    }\n}\n","import { sqlToProto } from \"./sql.js\";\nimport { valueToProto } from \"./value.js\";\n/** A statement that can be evaluated by the database. Besides the SQL text, it also contains the positional\n * and named arguments. */\nexport class Stmt {\n    /** The SQL statement text. */\n    sql;\n    /** @private */\n    _args;\n    /** @private */\n    _namedArgs;\n    /** Initialize the statement with given SQL text. */\n    constructor(sql) {\n        this.sql = sql;\n        this._args = [];\n        this._namedArgs = new Map();\n    }\n    /** Binds positional parameters from the given `values`. All previous positional bindings are cleared. */\n    bindIndexes(values) {\n        this._args.length = 0;\n        for (const value of values) {\n            this._args.push(valueToProto(value));\n        }\n        return this;\n    }\n    /** Binds a parameter by a 1-based index. */\n    bindIndex(index, value) {\n        if (index !== (index | 0) || index <= 0) {\n            throw new RangeError(\"Index of a positional argument must be positive integer\");\n        }\n        while (this._args.length < index) {\n            this._args.push(null);\n        }\n        this._args[index - 1] = valueToProto(value);\n        return this;\n    }\n    /** Binds a parameter by name. */\n    bindName(name, value) {\n        this._namedArgs.set(name, valueToProto(value));\n        return this;\n    }\n    /** Clears all bindings. */\n    unbindAll() {\n        this._args.length = 0;\n        this._namedArgs.clear();\n        return this;\n    }\n}\nexport function stmtToProto(sqlOwner, stmt, wantRows) {\n    let inSql;\n    let args = [];\n    let namedArgs = [];\n    if (stmt instanceof Stmt) {\n        inSql = stmt.sql;\n        args = stmt._args;\n        for (const [name, value] of stmt._namedArgs.entries()) {\n            namedArgs.push({ name, value });\n        }\n    }\n    else if (Array.isArray(stmt)) {\n        inSql = stmt[0];\n        if (Array.isArray(stmt[1])) {\n            args = stmt[1].map((arg) => valueToProto(arg));\n        }\n        else {\n            namedArgs = Object.entries(stmt[1]).map(([name, value]) => {\n                return { name, value: valueToProto(value) };\n            });\n        }\n    }\n    else {\n        inSql = stmt;\n    }\n    const { sql, sqlId } = sqlToProto(sqlOwner, inSql);\n    return { sql, sqlId, args, namedArgs, wantRows };\n}\n","import { ProtoError, MisuseError } from \"./errors.js\";\nimport { stmtResultFromProto, rowsResultFromProto, rowResultFromProto, valueResultFromProto, errorFromProto, } from \"./result.js\";\nimport { stmtToProto } from \"./stmt.js\";\nimport { impossible } from \"./util.js\";\n/** A builder for creating a batch and executing it on the server. */\nexport class Batch {\n    /** @private */\n    _stream;\n    #useCursor;\n    /** @private */\n    _steps;\n    #executed;\n    /** @private */\n    constructor(stream, useCursor) {\n        this._stream = stream;\n        this.#useCursor = useCursor;\n        this._steps = [];\n        this.#executed = false;\n    }\n    /** Return a builder for adding a step to the batch. */\n    step() {\n        return new BatchStep(this);\n    }\n    /** Execute the batch. */\n    execute() {\n        if (this.#executed) {\n            throw new MisuseError(\"This batch has already been executed\");\n        }\n        this.#executed = true;\n        const batch = {\n            steps: this._steps.map((step) => step.proto),\n        };\n        if (this.#useCursor) {\n            return executeCursor(this._stream, this._steps, batch);\n        }\n        else {\n            return executeRegular(this._stream, this._steps, batch);\n        }\n    }\n}\nfunction executeRegular(stream, steps, batch) {\n    return stream._batch(batch).then((result) => {\n        for (let step = 0; step < steps.length; ++step) {\n            const stepResult = result.stepResults.get(step);\n            const stepError = result.stepErrors.get(step);\n            steps[step].callback(stepResult, stepError);\n        }\n    });\n}\nasync function executeCursor(stream, steps, batch) {\n    const cursor = await stream._openCursor(batch);\n    try {\n        let nextStep = 0;\n        let beginEntry = undefined;\n        let rows = [];\n        for (;;) {\n            const entry = await cursor.next();\n            if (entry === undefined) {\n                break;\n            }\n            if (entry.type === \"step_begin\") {\n                if (entry.step < nextStep || entry.step >= steps.length) {\n                    throw new ProtoError(\"Server produced StepBeginEntry for unexpected step\");\n                }\n                else if (beginEntry !== undefined) {\n                    throw new ProtoError(\"Server produced StepBeginEntry before terminating previous step\");\n                }\n                for (let step = nextStep; step < entry.step; ++step) {\n                    steps[step].callback(undefined, undefined);\n                }\n                nextStep = entry.step + 1;\n                beginEntry = entry;\n                rows = [];\n            }\n            else if (entry.type === \"step_end\") {\n                if (beginEntry === undefined) {\n                    throw new ProtoError(\"Server produced StepEndEntry but no step is active\");\n                }\n                const stmtResult = {\n                    cols: beginEntry.cols,\n                    rows,\n                    affectedRowCount: entry.affectedRowCount,\n                    lastInsertRowid: entry.lastInsertRowid,\n                };\n                steps[beginEntry.step].callback(stmtResult, undefined);\n                beginEntry = undefined;\n                rows = [];\n            }\n            else if (entry.type === \"step_error\") {\n                if (beginEntry === undefined) {\n                    if (entry.step >= steps.length) {\n                        throw new ProtoError(\"Server produced StepErrorEntry for unexpected step\");\n                    }\n                    for (let step = nextStep; step < entry.step; ++step) {\n                        steps[step].callback(undefined, undefined);\n                    }\n                }\n                else {\n                    if (entry.step !== beginEntry.step) {\n                        throw new ProtoError(\"Server produced StepErrorEntry for unexpected step\");\n                    }\n                    beginEntry = undefined;\n                    rows = [];\n                }\n                steps[entry.step].callback(undefined, entry.error);\n                nextStep = entry.step + 1;\n            }\n            else if (entry.type === \"row\") {\n                if (beginEntry === undefined) {\n                    throw new ProtoError(\"Server produced RowEntry but no step is active\");\n                }\n                rows.push(entry.row);\n            }\n            else if (entry.type === \"error\") {\n                throw errorFromProto(entry.error);\n            }\n            else if (entry.type === \"none\") {\n                throw new ProtoError(\"Server produced unrecognized CursorEntry\");\n            }\n            else {\n                throw impossible(entry, \"Impossible CursorEntry\");\n            }\n        }\n        if (beginEntry !== undefined) {\n            throw new ProtoError(\"Server closed Cursor before terminating active step\");\n        }\n        for (let step = nextStep; step < steps.length; ++step) {\n            steps[step].callback(undefined, undefined);\n        }\n    }\n    finally {\n        cursor.close();\n    }\n}\n/** A builder for adding a step to the batch. */\nexport class BatchStep {\n    /** @private */\n    _batch;\n    #conds;\n    /** @private */\n    _index;\n    /** @private */\n    constructor(batch) {\n        this._batch = batch;\n        this.#conds = [];\n        this._index = undefined;\n    }\n    /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple\n     * times, we join the conditions with a logical AND. */\n    condition(cond) {\n        this.#conds.push(cond._proto);\n        return this;\n    }\n    /** Add a statement that returns rows. */\n    query(stmt) {\n        return this.#add(stmt, true, rowsResultFromProto);\n    }\n    /** Add a statement that returns at most a single row. */\n    queryRow(stmt) {\n        return this.#add(stmt, true, rowResultFromProto);\n    }\n    /** Add a statement that returns at most a single value. */\n    queryValue(stmt) {\n        return this.#add(stmt, true, valueResultFromProto);\n    }\n    /** Add a statement without returning rows. */\n    run(stmt) {\n        return this.#add(stmt, false, stmtResultFromProto);\n    }\n    #add(inStmt, wantRows, fromProto) {\n        if (this._index !== undefined) {\n            throw new MisuseError(\"This BatchStep has already been added to the batch\");\n        }\n        const stmt = stmtToProto(this._batch._stream._sqlOwner(), inStmt, wantRows);\n        let condition;\n        if (this.#conds.length === 0) {\n            condition = undefined;\n        }\n        else if (this.#conds.length === 1) {\n            condition = this.#conds[0];\n        }\n        else {\n            condition = { type: \"and\", conds: this.#conds.slice() };\n        }\n        const proto = { stmt, condition };\n        return new Promise((outputCallback, errorCallback) => {\n            const callback = (stepResult, stepError) => {\n                if (stepResult !== undefined && stepError !== undefined) {\n                    errorCallback(new ProtoError(\"Server returned both result and error\"));\n                }\n                else if (stepError !== undefined) {\n                    errorCallback(errorFromProto(stepError));\n                }\n                else if (stepResult !== undefined) {\n                    outputCallback(fromProto(stepResult, this._batch._stream.intMode));\n                }\n                else {\n                    outputCallback(undefined);\n                }\n            };\n            this._index = this._batch._steps.length;\n            this._batch._steps.push({ proto, callback });\n        });\n    }\n}\nexport class BatchCond {\n    /** @private */\n    _batch;\n    /** @private */\n    _proto;\n    /** @private */\n    constructor(batch, proto) {\n        this._batch = batch;\n        this._proto = proto;\n    }\n    /** Create a condition that evaluates to true when the given step executes successfully.\n     *\n     * If the given step fails error or is skipped because its condition evaluated to false, this\n     * condition evaluates to false.\n     */\n    static ok(step) {\n        return new BatchCond(step._batch, { type: \"ok\", step: stepIndex(step) });\n    }\n    /** Create a condition that evaluates to true when the given step fails.\n     *\n     * If the given step succeeds or is skipped because its condition evaluated to false, this condition\n     * evaluates to false.\n     */\n    static error(step) {\n        return new BatchCond(step._batch, { type: \"error\", step: stepIndex(step) });\n    }\n    /** Create a condition that is a logical negation of another condition.\n     */\n    static not(cond) {\n        return new BatchCond(cond._batch, { type: \"not\", cond: cond._proto });\n    }\n    /** Create a condition that is a logical AND of other conditions.\n     */\n    static and(batch, conds) {\n        for (const cond of conds) {\n            checkCondBatch(batch, cond);\n        }\n        return new BatchCond(batch, { type: \"and\", conds: conds.map(e => e._proto) });\n    }\n    /** Create a condition that is a logical OR of other conditions.\n     */\n    static or(batch, conds) {\n        for (const cond of conds) {\n            checkCondBatch(batch, cond);\n        }\n        return new BatchCond(batch, { type: \"or\", conds: conds.map(e => e._proto) });\n    }\n    /** Create a condition that evaluates to true when the SQL connection is in autocommit mode (not inside an\n     * explicit transaction). This requires protocol version 3 or higher.\n     */\n    static isAutocommit(batch) {\n        batch._stream.client()._ensureVersion(3, \"BatchCond.isAutocommit()\");\n        return new BatchCond(batch, { type: \"is_autocommit\" });\n    }\n}\nfunction stepIndex(step) {\n    if (step._index === undefined) {\n        throw new MisuseError(\"Cannot add a condition referencing a step that has not been added to the batch\");\n    }\n    return step._index;\n}\nfunction checkCondBatch(expectedBatch, cond) {\n    if (cond._batch !== expectedBatch) {\n        throw new MisuseError(\"Cannot mix BatchCond objects for different Batch objects\");\n    }\n}\n","export function describeResultFromProto(result) {\n    return {\n        paramNames: result.params.map((p) => p.name),\n        columns: result.cols,\n        isExplain: result.isExplain,\n        isReadonly: result.isReadonly,\n    };\n}\n","import { Batch } from \"./batch.js\";\nimport { describeResultFromProto } from \"./describe.js\";\nimport { stmtResultFromProto, rowsResultFromProto, rowResultFromProto, valueResultFromProto, } from \"./result.js\";\nimport { sqlToProto } from \"./sql.js\";\nimport { stmtToProto } from \"./stmt.js\";\n/** A stream for executing SQL statements (a \"database connection\"). */\nexport class Stream {\n    /** @private */\n    constructor(intMode) {\n        this.intMode = intMode;\n    }\n    /** Execute a statement and return rows. */\n    query(stmt) {\n        return this.#execute(stmt, true, rowsResultFromProto);\n    }\n    /** Execute a statement and return at most a single row. */\n    queryRow(stmt) {\n        return this.#execute(stmt, true, rowResultFromProto);\n    }\n    /** Execute a statement and return at most a single value. */\n    queryValue(stmt) {\n        return this.#execute(stmt, true, valueResultFromProto);\n    }\n    /** Execute a statement without returning rows. */\n    run(stmt) {\n        return this.#execute(stmt, false, stmtResultFromProto);\n    }\n    #execute(inStmt, wantRows, fromProto) {\n        const stmt = stmtToProto(this._sqlOwner(), inStmt, wantRows);\n        return this._execute(stmt).then((r) => fromProto(r, this.intMode));\n    }\n    /** Return a builder for creating and executing a batch.\n     *\n     * If `useCursor` is true, the batch will be executed using a Hrana cursor, which will stream results from\n     * the server to the client, which consumes less memory on the server. This requires protocol version 3 or\n     * higher.\n     */\n    batch(useCursor = false) {\n        return new Batch(this, useCursor);\n    }\n    /** Parse and analyze a statement. This requires protocol version 2 or higher. */\n    describe(inSql) {\n        const protoSql = sqlToProto(this._sqlOwner(), inSql);\n        return this._describe(protoSql).then(describeResultFromProto);\n    }\n    /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.\n     * */\n    sequence(inSql) {\n        const protoSql = sqlToProto(this._sqlOwner(), inSql);\n        return this._sequence(protoSql);\n    }\n    /** Representation of integers returned from the database. See {@link IntMode}.\n     *\n     * This value affects the results of all operations on this stream.\n     */\n    intMode;\n}\n","export class Cursor {\n}\n","import { ClientError, ClosedError } from \"../errors.js\";\nimport { Cursor } from \"../cursor.js\";\nimport { Queue } from \"../queue.js\";\nconst fetchChunkSize = 1000;\nconst fetchQueueSize = 10;\nexport class WsCursor extends Cursor {\n    #client;\n    #stream;\n    #cursorId;\n    #entryQueue;\n    #fetchQueue;\n    #closed;\n    #done;\n    /** @private */\n    constructor(client, stream, cursorId) {\n        super();\n        this.#client = client;\n        this.#stream = stream;\n        this.#cursorId = cursorId;\n        this.#entryQueue = new Queue();\n        this.#fetchQueue = new Queue();\n        this.#closed = undefined;\n        this.#done = false;\n    }\n    /** Fetch the next entry from the cursor. */\n    async next() {\n        for (;;) {\n            if (this.#closed !== undefined) {\n                throw new ClosedError(\"Cursor is closed\", this.#closed);\n            }\n            while (!this.#done && this.#fetchQueue.length < fetchQueueSize) {\n                this.#fetchQueue.push(this.#fetch());\n            }\n            const entry = this.#entryQueue.shift();\n            if (this.#done || entry !== undefined) {\n                return entry;\n            }\n            // we assume that `Cursor.next()` is never called concurrently\n            await this.#fetchQueue.shift().then((response) => {\n                if (response === undefined) {\n                    return;\n                }\n                for (const entry of response.entries) {\n                    this.#entryQueue.push(entry);\n                }\n                this.#done ||= response.done;\n            });\n        }\n    }\n    #fetch() {\n        return this.#stream._sendCursorRequest(this, {\n            type: \"fetch_cursor\",\n            cursorId: this.#cursorId,\n            maxCount: fetchChunkSize,\n        }).then((resp) => resp, (error) => {\n            this._setClosed(error);\n            return undefined;\n        });\n    }\n    /** @private */\n    _setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        this.#stream._sendCursorRequest(this, {\n            type: \"close_cursor\",\n            cursorId: this.#cursorId,\n        }).catch(() => undefined);\n        this.#stream._cursorClosed(this);\n    }\n    /** Close the cursor. */\n    close() {\n        this._setClosed(new ClientError(\"Cursor was manually closed\"));\n    }\n    /** True if the cursor is closed. */\n    get closed() {\n        return this.#closed !== undefined;\n    }\n}\n","import { ClientError, ClosedError, InternalError } from \"../errors.js\";\nimport { Queue } from \"../queue.js\";\nimport { Stream } from \"../stream.js\";\nimport { WsCursor } from \"./cursor.js\";\nexport class WsStream extends Stream {\n    #client;\n    #streamId;\n    #queue;\n    #cursor;\n    #closing;\n    #closed;\n    /** @private */\n    static open(client) {\n        const streamId = client._streamIdAlloc.alloc();\n        const stream = new WsStream(client, streamId);\n        const responseCallback = () => undefined;\n        const errorCallback = (e) => stream.#setClosed(e);\n        const request = { type: \"open_stream\", streamId };\n        client._sendRequest(request, { responseCallback, errorCallback });\n        return stream;\n    }\n    /** @private */\n    constructor(client, streamId) {\n        super(client.intMode);\n        this.#client = client;\n        this.#streamId = streamId;\n        this.#queue = new Queue();\n        this.#cursor = undefined;\n        this.#closing = false;\n        this.#closed = undefined;\n    }\n    /** Get the {@link WsClient} object that this stream belongs to. */\n    client() {\n        return this.#client;\n    }\n    /** @private */\n    _sqlOwner() {\n        return this.#client;\n    }\n    /** @private */\n    _execute(stmt) {\n        return this.#sendStreamRequest({\n            type: \"execute\",\n            streamId: this.#streamId,\n            stmt,\n        }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _batch(batch) {\n        return this.#sendStreamRequest({\n            type: \"batch\",\n            streamId: this.#streamId,\n            batch,\n        }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _describe(protoSql) {\n        this.#client._ensureVersion(2, \"describe()\");\n        return this.#sendStreamRequest({\n            type: \"describe\",\n            streamId: this.#streamId,\n            sql: protoSql.sql,\n            sqlId: protoSql.sqlId,\n        }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _sequence(protoSql) {\n        this.#client._ensureVersion(2, \"sequence()\");\n        return this.#sendStreamRequest({\n            type: \"sequence\",\n            streamId: this.#streamId,\n            sql: protoSql.sql,\n            sqlId: protoSql.sqlId,\n        }).then((_response) => {\n            return undefined;\n        });\n    }\n    /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an\n     * explicit transaction). This requires protocol version 3 or higher.\n     */\n    getAutocommit() {\n        this.#client._ensureVersion(3, \"getAutocommit()\");\n        return this.#sendStreamRequest({\n            type: \"get_autocommit\",\n            streamId: this.#streamId,\n        }).then((response) => {\n            return response.isAutocommit;\n        });\n    }\n    #sendStreamRequest(request) {\n        return new Promise((responseCallback, errorCallback) => {\n            this.#pushToQueue({ type: \"request\", request, responseCallback, errorCallback });\n        });\n    }\n    /** @private */\n    _openCursor(batch) {\n        this.#client._ensureVersion(3, \"cursor\");\n        return new Promise((cursorCallback, errorCallback) => {\n            this.#pushToQueue({ type: \"cursor\", batch, cursorCallback, errorCallback });\n        });\n    }\n    /** @private */\n    _sendCursorRequest(cursor, request) {\n        if (cursor !== this.#cursor) {\n            throw new InternalError(\"Cursor not associated with the stream attempted to execute a request\");\n        }\n        return new Promise((responseCallback, errorCallback) => {\n            if (this.#closed !== undefined) {\n                errorCallback(new ClosedError(\"Stream is closed\", this.#closed));\n            }\n            else {\n                this.#client._sendRequest(request, { responseCallback, errorCallback });\n            }\n        });\n    }\n    /** @private */\n    _cursorClosed(cursor) {\n        if (cursor !== this.#cursor) {\n            throw new InternalError(\"Cursor was closed, but it was not associated with the stream\");\n        }\n        this.#cursor = undefined;\n        this.#flushQueue();\n    }\n    #pushToQueue(entry) {\n        if (this.#closed !== undefined) {\n            entry.errorCallback(new ClosedError(\"Stream is closed\", this.#closed));\n        }\n        else if (this.#closing) {\n            entry.errorCallback(new ClosedError(\"Stream is closing\", undefined));\n        }\n        else {\n            this.#queue.push(entry);\n            this.#flushQueue();\n        }\n    }\n    #flushQueue() {\n        for (;;) {\n            const entry = this.#queue.first();\n            if (entry === undefined && this.#cursor === undefined && this.#closing) {\n                this.#setClosed(new ClientError(\"Stream was gracefully closed\"));\n                break;\n            }\n            else if (entry?.type === \"request\" && this.#cursor === undefined) {\n                const { request, responseCallback, errorCallback } = entry;\n                this.#queue.shift();\n                this.#client._sendRequest(request, { responseCallback, errorCallback });\n            }\n            else if (entry?.type === \"cursor\" && this.#cursor === undefined) {\n                const { batch, cursorCallback } = entry;\n                this.#queue.shift();\n                const cursorId = this.#client._cursorIdAlloc.alloc();\n                const cursor = new WsCursor(this.#client, this, cursorId);\n                const request = {\n                    type: \"open_cursor\",\n                    streamId: this.#streamId,\n                    cursorId,\n                    batch,\n                };\n                const responseCallback = () => undefined;\n                const errorCallback = (e) => cursor._setClosed(e);\n                this.#client._sendRequest(request, { responseCallback, errorCallback });\n                this.#cursor = cursor;\n                cursorCallback(cursor);\n            }\n            else {\n                break;\n            }\n        }\n    }\n    #setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        if (this.#cursor !== undefined) {\n            this.#cursor._setClosed(error);\n        }\n        for (;;) {\n            const entry = this.#queue.shift();\n            if (entry !== undefined) {\n                entry.errorCallback(error);\n            }\n            else {\n                break;\n            }\n        }\n        const request = { type: \"close_stream\", streamId: this.#streamId };\n        const responseCallback = () => this.#client._streamIdAlloc.free(this.#streamId);\n        const errorCallback = () => undefined;\n        this.#client._sendRequest(request, { responseCallback, errorCallback });\n    }\n    /** Immediately close the stream. */\n    close() {\n        this.#setClosed(new ClientError(\"Stream was manually closed\"));\n    }\n    /** Gracefully close the stream. */\n    closeGracefully() {\n        this.#closing = true;\n        this.#flushQueue();\n    }\n    /** True if the stream is closed or closing. */\n    get closed() {\n        return this.#closed !== undefined || this.#closing;\n    }\n}\n","import { Base64 } from \"js-base64\";\nimport { impossible } from \"../util.js\";\nexport function Stmt(w, msg) {\n    if (msg.sql !== undefined) {\n        w.string(\"sql\", msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.number(\"sql_id\", msg.sqlId);\n    }\n    w.arrayObjects(\"args\", msg.args, Value);\n    w.arrayObjects(\"named_args\", msg.namedArgs, NamedArg);\n    w.boolean(\"want_rows\", msg.wantRows);\n}\nfunction NamedArg(w, msg) {\n    w.string(\"name\", msg.name);\n    w.object(\"value\", msg.value, Value);\n}\nexport function Batch(w, msg) {\n    w.arrayObjects(\"steps\", msg.steps, BatchStep);\n}\nfunction BatchStep(w, msg) {\n    if (msg.condition !== undefined) {\n        w.object(\"condition\", msg.condition, BatchCond);\n    }\n    w.object(\"stmt\", msg.stmt, Stmt);\n}\nfunction BatchCond(w, msg) {\n    w.stringRaw(\"type\", msg.type);\n    if (msg.type === \"ok\" || msg.type === \"error\") {\n        w.number(\"step\", msg.step);\n    }\n    else if (msg.type === \"not\") {\n        w.object(\"cond\", msg.cond, BatchCond);\n    }\n    else if (msg.type === \"and\" || msg.type === \"or\") {\n        w.arrayObjects(\"conds\", msg.conds, BatchCond);\n    }\n    else if (msg.type === \"is_autocommit\") {\n        // do nothing\n    }\n    else {\n        throw impossible(msg, \"Impossible type of BatchCond\");\n    }\n}\nfunction Value(w, msg) {\n    if (msg === null) {\n        w.stringRaw(\"type\", \"null\");\n    }\n    else if (typeof msg === \"bigint\") {\n        w.stringRaw(\"type\", \"integer\");\n        w.stringRaw(\"value\", \"\" + msg);\n    }\n    else if (typeof msg === \"number\") {\n        w.stringRaw(\"type\", \"float\");\n        w.number(\"value\", msg);\n    }\n    else if (typeof msg === \"string\") {\n        w.stringRaw(\"type\", \"text\");\n        w.string(\"value\", msg);\n    }\n    else if (msg instanceof Uint8Array) {\n        w.stringRaw(\"type\", \"blob\");\n        w.stringRaw(\"base64\", Base64.fromUint8Array(msg));\n    }\n    else if (msg === undefined) {\n        // do nothing\n    }\n    else {\n        throw impossible(msg, \"Impossible type of Value\");\n    }\n}\n","import { Stmt, Batch } from \"../shared/json_encode.js\";\nimport { impossible } from \"../util.js\";\nexport function ClientMsg(w, msg) {\n    w.stringRaw(\"type\", msg.type);\n    if (msg.type === \"hello\") {\n        if (msg.jwt !== undefined) {\n            w.string(\"jwt\", msg.jwt);\n        }\n    }\n    else if (msg.type === \"request\") {\n        w.number(\"request_id\", msg.requestId);\n        w.object(\"request\", msg.request, Request);\n    }\n    else {\n        throw impossible(msg, \"Impossible type of ClientMsg\");\n    }\n}\nfunction Request(w, msg) {\n    w.stringRaw(\"type\", msg.type);\n    if (msg.type === \"open_stream\") {\n        w.number(\"stream_id\", msg.streamId);\n    }\n    else if (msg.type === \"close_stream\") {\n        w.number(\"stream_id\", msg.streamId);\n    }\n    else if (msg.type === \"execute\") {\n        w.number(\"stream_id\", msg.streamId);\n        w.object(\"stmt\", msg.stmt, Stmt);\n    }\n    else if (msg.type === \"batch\") {\n        w.number(\"stream_id\", msg.streamId);\n        w.object(\"batch\", msg.batch, Batch);\n    }\n    else if (msg.type === \"open_cursor\") {\n        w.number(\"stream_id\", msg.streamId);\n        w.number(\"cursor_id\", msg.cursorId);\n        w.object(\"batch\", msg.batch, Batch);\n    }\n    else if (msg.type === \"close_cursor\") {\n        w.number(\"cursor_id\", msg.cursorId);\n    }\n    else if (msg.type === \"fetch_cursor\") {\n        w.number(\"cursor_id\", msg.cursorId);\n        w.number(\"max_count\", msg.maxCount);\n    }\n    else if (msg.type === \"sequence\") {\n        w.number(\"stream_id\", msg.streamId);\n        if (msg.sql !== undefined) {\n            w.string(\"sql\", msg.sql);\n        }\n        if (msg.sqlId !== undefined) {\n            w.number(\"sql_id\", msg.sqlId);\n        }\n    }\n    else if (msg.type === \"describe\") {\n        w.number(\"stream_id\", msg.streamId);\n        if (msg.sql !== undefined) {\n            w.string(\"sql\", msg.sql);\n        }\n        if (msg.sqlId !== undefined) {\n            w.number(\"sql_id\", msg.sqlId);\n        }\n    }\n    else if (msg.type === \"store_sql\") {\n        w.number(\"sql_id\", msg.sqlId);\n        w.string(\"sql\", msg.sql);\n    }\n    else if (msg.type === \"close_sql\") {\n        w.number(\"sql_id\", msg.sqlId);\n    }\n    else if (msg.type === \"get_autocommit\") {\n        w.number(\"stream_id\", msg.streamId);\n    }\n    else {\n        throw impossible(msg, \"Impossible type of Request\");\n    }\n}\n","import { impossible } from \"../util.js\";\nexport function Stmt(w, msg) {\n    if (msg.sql !== undefined) {\n        w.string(1, msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.int32(2, msg.sqlId);\n    }\n    for (const arg of msg.args) {\n        w.message(3, arg, Value);\n    }\n    for (const arg of msg.namedArgs) {\n        w.message(4, arg, NamedArg);\n    }\n    w.bool(5, msg.wantRows);\n}\nfunction NamedArg(w, msg) {\n    w.string(1, msg.name);\n    w.message(2, msg.value, Value);\n}\nexport function Batch(w, msg) {\n    for (const step of msg.steps) {\n        w.message(1, step, BatchStep);\n    }\n}\nfunction BatchStep(w, msg) {\n    if (msg.condition !== undefined) {\n        w.message(1, msg.condition, BatchCond);\n    }\n    w.message(2, msg.stmt, Stmt);\n}\nfunction BatchCond(w, msg) {\n    if (msg.type === \"ok\") {\n        w.uint32(1, msg.step);\n    }\n    else if (msg.type === \"error\") {\n        w.uint32(2, msg.step);\n    }\n    else if (msg.type === \"not\") {\n        w.message(3, msg.cond, BatchCond);\n    }\n    else if (msg.type === \"and\") {\n        w.message(4, msg.conds, BatchCondList);\n    }\n    else if (msg.type === \"or\") {\n        w.message(5, msg.conds, BatchCondList);\n    }\n    else if (msg.type === \"is_autocommit\") {\n        w.message(6, undefined, Empty);\n    }\n    else {\n        throw impossible(msg, \"Impossible type of BatchCond\");\n    }\n}\nfunction BatchCondList(w, msg) {\n    for (const cond of msg) {\n        w.message(1, cond, BatchCond);\n    }\n}\nfunction Value(w, msg) {\n    if (msg === null) {\n        w.message(1, undefined, Empty);\n    }\n    else if (typeof msg === \"bigint\") {\n        w.sint64(2, msg);\n    }\n    else if (typeof msg === \"number\") {\n        w.double(3, msg);\n    }\n    else if (typeof msg === \"string\") {\n        w.string(4, msg);\n    }\n    else if (msg instanceof Uint8Array) {\n        w.bytes(5, msg);\n    }\n    else if (msg === undefined) {\n        // do nothing\n    }\n    else {\n        throw impossible(msg, \"Impossible type of Value\");\n    }\n}\nfunction Empty(_w, _msg) {\n    // do nothing\n}\n","import { Stmt, Batch } from \"../shared/protobuf_encode.js\";\nimport { impossible } from \"../util.js\";\nexport function ClientMsg(w, msg) {\n    if (msg.type === \"hello\") {\n        w.message(1, msg, HelloMsg);\n    }\n    else if (msg.type === \"request\") {\n        w.message(2, msg, RequestMsg);\n    }\n    else {\n        throw impossible(msg, \"Impossible type of ClientMsg\");\n    }\n}\nfunction HelloMsg(w, msg) {\n    if (msg.jwt !== undefined) {\n        w.string(1, msg.jwt);\n    }\n}\nfunction RequestMsg(w, msg) {\n    w.int32(1, msg.requestId);\n    const request = msg.request;\n    if (request.type === \"open_stream\") {\n        w.message(2, request, OpenStreamReq);\n    }\n    else if (request.type === \"close_stream\") {\n        w.message(3, request, CloseStreamReq);\n    }\n    else if (request.type === \"execute\") {\n        w.message(4, request, ExecuteReq);\n    }\n    else if (request.type === \"batch\") {\n        w.message(5, request, BatchReq);\n    }\n    else if (request.type === \"open_cursor\") {\n        w.message(6, request, OpenCursorReq);\n    }\n    else if (request.type === \"close_cursor\") {\n        w.message(7, request, CloseCursorReq);\n    }\n    else if (request.type === \"fetch_cursor\") {\n        w.message(8, request, FetchCursorReq);\n    }\n    else if (request.type === \"sequence\") {\n        w.message(9, request, SequenceReq);\n    }\n    else if (request.type === \"describe\") {\n        w.message(10, request, DescribeReq);\n    }\n    else if (request.type === \"store_sql\") {\n        w.message(11, request, StoreSqlReq);\n    }\n    else if (request.type === \"close_sql\") {\n        w.message(12, request, CloseSqlReq);\n    }\n    else if (request.type === \"get_autocommit\") {\n        w.message(13, request, GetAutocommitReq);\n    }\n    else {\n        throw impossible(request, \"Impossible type of Request\");\n    }\n}\nfunction OpenStreamReq(w, msg) {\n    w.int32(1, msg.streamId);\n}\nfunction CloseStreamReq(w, msg) {\n    w.int32(1, msg.streamId);\n}\nfunction ExecuteReq(w, msg) {\n    w.int32(1, msg.streamId);\n    w.message(2, msg.stmt, Stmt);\n}\nfunction BatchReq(w, msg) {\n    w.int32(1, msg.streamId);\n    w.message(2, msg.batch, Batch);\n}\nfunction OpenCursorReq(w, msg) {\n    w.int32(1, msg.streamId);\n    w.int32(2, msg.cursorId);\n    w.message(3, msg.batch, Batch);\n}\nfunction CloseCursorReq(w, msg) {\n    w.int32(1, msg.cursorId);\n}\nfunction FetchCursorReq(w, msg) {\n    w.int32(1, msg.cursorId);\n    w.uint32(2, msg.maxCount);\n}\nfunction SequenceReq(w, msg) {\n    w.int32(1, msg.streamId);\n    if (msg.sql !== undefined) {\n        w.string(2, msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.int32(3, msg.sqlId);\n    }\n}\nfunction DescribeReq(w, msg) {\n    w.int32(1, msg.streamId);\n    if (msg.sql !== undefined) {\n        w.string(2, msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.int32(3, msg.sqlId);\n    }\n}\nfunction StoreSqlReq(w, msg) {\n    w.int32(1, msg.sqlId);\n    w.string(2, msg.sql);\n}\nfunction CloseSqlReq(w, msg) {\n    w.int32(1, msg.sqlId);\n}\nfunction GetAutocommitReq(w, msg) {\n    w.int32(1, msg.streamId);\n}\n","import { Base64 } from \"js-base64\";\nimport { ProtoError } from \"../errors.js\";\nimport * as d from \"../encoding/json/decode.js\";\nexport function Error(obj) {\n    const message = d.string(obj[\"message\"]);\n    const code = d.stringOpt(obj[\"code\"]);\n    return { message, code };\n}\nexport function StmtResult(obj) {\n    const cols = d.arrayObjectsMap(obj[\"cols\"], Col);\n    const rows = d.array(obj[\"rows\"]).map((rowObj) => d.arrayObjectsMap(rowObj, Value));\n    const affectedRowCount = d.number(obj[\"affected_row_count\"]);\n    const lastInsertRowidStr = d.stringOpt(obj[\"last_insert_rowid\"]);\n    const lastInsertRowid = lastInsertRowidStr !== undefined\n        ? BigInt(lastInsertRowidStr) : undefined;\n    return { cols, rows, affectedRowCount, lastInsertRowid };\n}\nfunction Col(obj) {\n    const name = d.stringOpt(obj[\"name\"]);\n    const decltype = d.stringOpt(obj[\"decltype\"]);\n    return { name, decltype };\n}\nexport function BatchResult(obj) {\n    const stepResults = new Map();\n    d.array(obj[\"step_results\"]).forEach((value, i) => {\n        if (value !== null) {\n            stepResults.set(i, StmtResult(d.object(value)));\n        }\n    });\n    const stepErrors = new Map();\n    d.array(obj[\"step_errors\"]).forEach((value, i) => {\n        if (value !== null) {\n            stepErrors.set(i, Error(d.object(value)));\n        }\n    });\n    return { stepResults, stepErrors };\n}\nexport function CursorEntry(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"step_begin\") {\n        const step = d.number(obj[\"step\"]);\n        const cols = d.arrayObjectsMap(obj[\"cols\"], Col);\n        return { type: \"step_begin\", step, cols };\n    }\n    else if (type === \"step_end\") {\n        const affectedRowCount = d.number(obj[\"affected_row_count\"]);\n        const lastInsertRowidStr = d.stringOpt(obj[\"last_insert_rowid\"]);\n        const lastInsertRowid = lastInsertRowidStr !== undefined\n            ? BigInt(lastInsertRowidStr) : undefined;\n        return { type: \"step_end\", affectedRowCount, lastInsertRowid };\n    }\n    else if (type === \"step_error\") {\n        const step = d.number(obj[\"step\"]);\n        const error = Error(d.object(obj[\"error\"]));\n        return { type: \"step_error\", step, error };\n    }\n    else if (type === \"row\") {\n        const row = d.arrayObjectsMap(obj[\"row\"], Value);\n        return { type: \"row\", row };\n    }\n    else if (type === \"error\") {\n        const error = Error(d.object(obj[\"error\"]));\n        return { type: \"error\", error };\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of CursorEntry\");\n    }\n}\nexport function DescribeResult(obj) {\n    const params = d.arrayObjectsMap(obj[\"params\"], DescribeParam);\n    const cols = d.arrayObjectsMap(obj[\"cols\"], DescribeCol);\n    const isExplain = d.boolean(obj[\"is_explain\"]);\n    const isReadonly = d.boolean(obj[\"is_readonly\"]);\n    return { params, cols, isExplain, isReadonly };\n}\nfunction DescribeParam(obj) {\n    const name = d.stringOpt(obj[\"name\"]);\n    return { name };\n}\nfunction DescribeCol(obj) {\n    const name = d.string(obj[\"name\"]);\n    const decltype = d.stringOpt(obj[\"decltype\"]);\n    return { name, decltype };\n}\nexport function Value(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"null\") {\n        return null;\n    }\n    else if (type === \"integer\") {\n        const value = d.string(obj[\"value\"]);\n        return BigInt(value);\n    }\n    else if (type === \"float\") {\n        return d.number(obj[\"value\"]);\n    }\n    else if (type === \"text\") {\n        return d.string(obj[\"value\"]);\n    }\n    else if (type === \"blob\") {\n        return Base64.toUint8Array(d.string(obj[\"base64\"]));\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of Value\");\n    }\n}\n","import { ProtoError } from \"../errors.js\";\nimport * as d from \"../encoding/json/decode.js\";\nimport { Error, StmtResult, BatchResult, CursorEntry, DescribeResult } from \"../shared/json_decode.js\";\nexport function ServerMsg(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"hello_ok\") {\n        return { type: \"hello_ok\" };\n    }\n    else if (type === \"hello_error\") {\n        const error = Error(d.object(obj[\"error\"]));\n        return { type: \"hello_error\", error };\n    }\n    else if (type === \"response_ok\") {\n        const requestId = d.number(obj[\"request_id\"]);\n        const response = Response(d.object(obj[\"response\"]));\n        return { type: \"response_ok\", requestId, response };\n    }\n    else if (type === \"response_error\") {\n        const requestId = d.number(obj[\"request_id\"]);\n        const error = Error(d.object(obj[\"error\"]));\n        return { type: \"response_error\", requestId, error };\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of ServerMsg\");\n    }\n}\nfunction Response(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"open_stream\") {\n        return { type: \"open_stream\" };\n    }\n    else if (type === \"close_stream\") {\n        return { type: \"close_stream\" };\n    }\n    else if (type === \"execute\") {\n        const result = StmtResult(d.object(obj[\"result\"]));\n        return { type: \"execute\", result };\n    }\n    else if (type === \"batch\") {\n        const result = BatchResult(d.object(obj[\"result\"]));\n        return { type: \"batch\", result };\n    }\n    else if (type === \"open_cursor\") {\n        return { type: \"open_cursor\" };\n    }\n    else if (type === \"close_cursor\") {\n        return { type: \"close_cursor\" };\n    }\n    else if (type === \"fetch_cursor\") {\n        const entries = d.arrayObjectsMap(obj[\"entries\"], CursorEntry);\n        const done = d.boolean(obj[\"done\"]);\n        return { type: \"fetch_cursor\", entries, done };\n    }\n    else if (type === \"sequence\") {\n        return { type: \"sequence\" };\n    }\n    else if (type === \"describe\") {\n        const result = DescribeResult(d.object(obj[\"result\"]));\n        return { type: \"describe\", result };\n    }\n    else if (type === \"store_sql\") {\n        return { type: \"store_sql\" };\n    }\n    else if (type === \"close_sql\") {\n        return { type: \"close_sql\" };\n    }\n    else if (type === \"get_autocommit\") {\n        const isAutocommit = d.boolean(obj[\"is_autocommit\"]);\n        return { type: \"get_autocommit\", isAutocommit };\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of Response\");\n    }\n}\n","export const Error = {\n    default() { return { message: \"\", code: undefined }; },\n    1(r, msg) { msg.message = r.string(); },\n    2(r, msg) { msg.code = r.string(); },\n};\nexport const StmtResult = {\n    default() {\n        return {\n            cols: [],\n            rows: [],\n            affectedRowCount: 0,\n            lastInsertRowid: undefined,\n        };\n    },\n    1(r, msg) { msg.cols.push(r.message(Col)); },\n    2(r, msg) { msg.rows.push(r.message(Row)); },\n    3(r, msg) { msg.affectedRowCount = Number(r.uint64()); },\n    4(r, msg) { msg.lastInsertRowid = r.sint64(); },\n};\nconst Col = {\n    default() { return { name: undefined, decltype: undefined }; },\n    1(r, msg) { msg.name = r.string(); },\n    2(r, msg) { msg.decltype = r.string(); },\n};\nconst Row = {\n    default() { return []; },\n    1(r, msg) { msg.push(r.message(Value)); },\n};\nexport const BatchResult = {\n    default() { return { stepResults: new Map(), stepErrors: new Map() }; },\n    1(r, msg) {\n        const [key, value] = r.message(BatchResultStepResult);\n        msg.stepResults.set(key, value);\n    },\n    2(r, msg) {\n        const [key, value] = r.message(BatchResultStepError);\n        msg.stepErrors.set(key, value);\n    },\n};\nconst BatchResultStepResult = {\n    default() { return [0, StmtResult.default()]; },\n    1(r, msg) { msg[0] = r.uint32(); },\n    2(r, msg) { msg[1] = r.message(StmtResult); },\n};\nconst BatchResultStepError = {\n    default() { return [0, Error.default()]; },\n    1(r, msg) { msg[0] = r.uint32(); },\n    2(r, msg) { msg[1] = r.message(Error); },\n};\nexport const CursorEntry = {\n    default() { return { type: \"none\" }; },\n    1(r) { return r.message(StepBeginEntry); },\n    2(r) { return r.message(StepEndEntry); },\n    3(r) { return r.message(StepErrorEntry); },\n    4(r) { return { type: \"row\", row: r.message(Row) }; },\n    5(r) { return { type: \"error\", error: r.message(Error) }; },\n};\nconst StepBeginEntry = {\n    default() { return { type: \"step_begin\", step: 0, cols: [] }; },\n    1(r, msg) { msg.step = r.uint32(); },\n    2(r, msg) { msg.cols.push(r.message(Col)); },\n};\nconst StepEndEntry = {\n    default() {\n        return {\n            type: \"step_end\",\n            affectedRowCount: 0,\n            lastInsertRowid: undefined,\n        };\n    },\n    1(r, msg) { msg.affectedRowCount = r.uint32(); },\n    2(r, msg) { msg.lastInsertRowid = r.uint64(); },\n};\nconst StepErrorEntry = {\n    default() {\n        return {\n            type: \"step_error\",\n            step: 0,\n            error: Error.default(),\n        };\n    },\n    1(r, msg) { msg.step = r.uint32(); },\n    2(r, msg) { msg.error = r.message(Error); },\n};\nexport const DescribeResult = {\n    default() {\n        return {\n            params: [],\n            cols: [],\n            isExplain: false,\n            isReadonly: false,\n        };\n    },\n    1(r, msg) { msg.params.push(r.message(DescribeParam)); },\n    2(r, msg) { msg.cols.push(r.message(DescribeCol)); },\n    3(r, msg) { msg.isExplain = r.bool(); },\n    4(r, msg) { msg.isReadonly = r.bool(); },\n};\nconst DescribeParam = {\n    default() { return { name: undefined }; },\n    1(r, msg) { msg.name = r.string(); },\n};\nconst DescribeCol = {\n    default() { return { name: \"\", decltype: undefined }; },\n    1(r, msg) { msg.name = r.string(); },\n    2(r, msg) { msg.decltype = r.string(); },\n};\nconst Value = {\n    default() { return undefined; },\n    1(r) { return null; },\n    2(r) { return r.sint64(); },\n    3(r) { return r.double(); },\n    4(r) { return r.string(); },\n    5(r) { return r.bytes(); },\n};\n","import { Error, StmtResult, BatchResult, CursorEntry, DescribeResult } from \"../shared/protobuf_decode.js\";\nexport const ServerMsg = {\n    default() { return { type: \"none\" }; },\n    1(r) { return { type: \"hello_ok\" }; },\n    2(r) { return r.message(HelloErrorMsg); },\n    3(r) { return r.message(ResponseOkMsg); },\n    4(r) { return r.message(ResponseErrorMsg); },\n};\nconst HelloErrorMsg = {\n    default() { return { type: \"hello_error\", error: Error.default() }; },\n    1(r, msg) { msg.error = r.message(Error); },\n};\nconst ResponseErrorMsg = {\n    default() { return { type: \"response_error\", requestId: 0, error: Error.default() }; },\n    1(r, msg) { msg.requestId = r.int32(); },\n    2(r, msg) { msg.error = r.message(Error); },\n};\nconst ResponseOkMsg = {\n    default() {\n        return {\n            type: \"response_ok\",\n            requestId: 0,\n            response: { type: \"none\" },\n        };\n    },\n    1(r, msg) { msg.requestId = r.int32(); },\n    2(r, msg) { msg.response = { type: \"open_stream\" }; },\n    3(r, msg) { msg.response = { type: \"close_stream\" }; },\n    4(r, msg) { msg.response = r.message(ExecuteResp); },\n    5(r, msg) { msg.response = r.message(BatchResp); },\n    6(r, msg) { msg.response = { type: \"open_cursor\" }; },\n    7(r, msg) { msg.response = { type: \"close_cursor\" }; },\n    8(r, msg) { msg.response = r.message(FetchCursorResp); },\n    9(r, msg) { msg.response = { type: \"sequence\" }; },\n    10(r, msg) { msg.response = r.message(DescribeResp); },\n    11(r, msg) { msg.response = { type: \"store_sql\" }; },\n    12(r, msg) { msg.response = { type: \"close_sql\" }; },\n    13(r, msg) { msg.response = r.message(GetAutocommitResp); },\n};\nconst ExecuteResp = {\n    default() { return { type: \"execute\", result: StmtResult.default() }; },\n    1(r, msg) { msg.result = r.message(StmtResult); },\n};\nconst BatchResp = {\n    default() { return { type: \"batch\", result: BatchResult.default() }; },\n    1(r, msg) { msg.result = r.message(BatchResult); },\n};\nconst FetchCursorResp = {\n    default() { return { type: \"fetch_cursor\", entries: [], done: false }; },\n    1(r, msg) { msg.entries.push(r.message(CursorEntry)); },\n    2(r, msg) { msg.done = r.bool(); },\n};\nconst DescribeResp = {\n    default() { return { type: \"describe\", result: DescribeResult.default() }; },\n    1(r, msg) { msg.result = r.message(DescribeResult); },\n};\nconst GetAutocommitResp = {\n    default() { return { type: \"get_autocommit\", isAutocommit: false }; },\n    1(r, msg) { msg.isAutocommit = r.bool(); },\n};\n","import { Client } from \"../client.js\";\nimport { readJsonObject, writeJsonObject, readProtobufMessage, writeProtobufMessage, } from \"../encoding/index.js\";\nimport { ClientError, ProtoError, ClosedError, WebSocketError, ProtocolVersionError, InternalError, } from \"../errors.js\";\nimport { IdAlloc } from \"../id_alloc.js\";\nimport { errorFromProto } from \"../result.js\";\nimport { Sql } from \"../sql.js\";\nimport { impossible } from \"../util.js\";\nimport { WsStream } from \"./stream.js\";\nimport { ClientMsg as json_ClientMsg } from \"./json_encode.js\";\nimport { ClientMsg as protobuf_ClientMsg } from \"./protobuf_encode.js\";\nimport { ServerMsg as json_ServerMsg } from \"./json_decode.js\";\nimport { ServerMsg as protobuf_ServerMsg } from \"./protobuf_decode.js\";\nexport const subprotocolsV2 = new Map([\n    [\"hrana2\", { version: 2, encoding: \"json\" }],\n    [\"hrana1\", { version: 1, encoding: \"json\" }],\n]);\nexport const subprotocolsV3 = new Map([\n    [\"hrana3-protobuf\", { version: 3, encoding: \"protobuf\" }],\n    [\"hrana3\", { version: 3, encoding: \"json\" }],\n    [\"hrana2\", { version: 2, encoding: \"json\" }],\n    [\"hrana1\", { version: 1, encoding: \"json\" }],\n]);\n/** A client for the Hrana protocol over a WebSocket. */\nexport class WsClient extends Client {\n    #socket;\n    // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.\n    #openCallbacks;\n    // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?\n    #opened;\n    // Stores the error that caused us to close the client (and the socket). If we are not closed, this is\n    // `undefined`.\n    #closed;\n    // Have we received a response to our \"hello\" from the server?\n    #recvdHello;\n    // Subprotocol negotiated with the server. It is only available after the socket transitions to the OPEN\n    // state.\n    #subprotocol;\n    // Has the `getVersion()` function been called? This is only used to validate that the API is used\n    // correctly.\n    #getVersionCalled;\n    // A map from request id to the responses that we expect to receive from the server.\n    #responseMap;\n    // An allocator of request ids.\n    #requestIdAlloc;\n    // An allocator of stream ids.\n    /** @private */\n    _streamIdAlloc;\n    // An allocator of cursor ids.\n    /** @private */\n    _cursorIdAlloc;\n    // An allocator of SQL text ids.\n    #sqlIdAlloc;\n    /** @private */\n    constructor(socket, jwt) {\n        super();\n        this.#socket = socket;\n        this.#openCallbacks = [];\n        this.#opened = false;\n        this.#closed = undefined;\n        this.#recvdHello = false;\n        this.#subprotocol = undefined;\n        this.#getVersionCalled = false;\n        this.#responseMap = new Map();\n        this.#requestIdAlloc = new IdAlloc();\n        this._streamIdAlloc = new IdAlloc();\n        this._cursorIdAlloc = new IdAlloc();\n        this.#sqlIdAlloc = new IdAlloc();\n        this.#socket.binaryType = \"arraybuffer\";\n        this.#socket.addEventListener(\"open\", () => this.#onSocketOpen());\n        this.#socket.addEventListener(\"close\", (event) => this.#onSocketClose(event));\n        this.#socket.addEventListener(\"error\", (event) => this.#onSocketError(event));\n        this.#socket.addEventListener(\"message\", (event) => this.#onSocketMessage(event));\n        this.#send({ type: \"hello\", jwt });\n    }\n    // Send (or enqueue to send) a message to the server.\n    #send(msg) {\n        if (this.#closed !== undefined) {\n            throw new InternalError(\"Trying to send a message on a closed client\");\n        }\n        if (this.#opened) {\n            this.#sendToSocket(msg);\n        }\n        else {\n            const openCallback = () => this.#sendToSocket(msg);\n            const errorCallback = () => undefined;\n            this.#openCallbacks.push({ openCallback, errorCallback });\n        }\n    }\n    // The socket transitioned from CONNECTING to OPEN\n    #onSocketOpen() {\n        const protocol = this.#socket.protocol;\n        if (protocol === undefined) {\n            this.#setClosed(new ClientError(\"The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket \" +\n                \"implementation provided by the environment is broken. If you are using Miniflare 2, \" +\n                \"please update to Miniflare 3, which fixes this problem.\"));\n            return;\n        }\n        else if (protocol === \"\") {\n            this.#subprotocol = { version: 1, encoding: \"json\" };\n        }\n        else {\n            this.#subprotocol = subprotocolsV3.get(protocol);\n            if (this.#subprotocol === undefined) {\n                this.#setClosed(new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));\n                return;\n            }\n        }\n        for (const callbacks of this.#openCallbacks) {\n            callbacks.openCallback();\n        }\n        this.#openCallbacks.length = 0;\n        this.#opened = true;\n    }\n    #sendToSocket(msg) {\n        const encoding = this.#subprotocol.encoding;\n        if (encoding === \"json\") {\n            const jsonMsg = writeJsonObject(msg, json_ClientMsg);\n            this.#socket.send(jsonMsg);\n        }\n        else if (encoding === \"protobuf\") {\n            const protobufMsg = writeProtobufMessage(msg, protobuf_ClientMsg);\n            this.#socket.send(protobufMsg);\n        }\n        else {\n            throw impossible(encoding, \"Impossible encoding\");\n        }\n    }\n    /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */\n    getVersion() {\n        return new Promise((versionCallback, errorCallback) => {\n            this.#getVersionCalled = true;\n            if (this.#closed !== undefined) {\n                errorCallback(this.#closed);\n            }\n            else if (!this.#opened) {\n                const openCallback = () => versionCallback(this.#subprotocol.version);\n                this.#openCallbacks.push({ openCallback, errorCallback });\n            }\n            else {\n                versionCallback(this.#subprotocol.version);\n            }\n        });\n    }\n    // Make sure that the negotiated version is at least `minVersion`.\n    /** @private */\n    _ensureVersion(minVersion, feature) {\n        if (this.#subprotocol === undefined || !this.#getVersionCalled) {\n            throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` +\n                \"but the version supported by the WebSocket server is not yet known. \" +\n                \"Use Client.getVersion() to wait until the version is available.\");\n        }\n        else if (this.#subprotocol.version < minVersion) {\n            throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, ` +\n                `but the WebSocket server only supports version ${this.#subprotocol.version}`);\n        }\n    }\n    // Send a request to the server and invoke a callback when we get the response.\n    /** @private */\n    _sendRequest(request, callbacks) {\n        if (this.#closed !== undefined) {\n            callbacks.errorCallback(new ClosedError(\"Client is closed\", this.#closed));\n            return;\n        }\n        const requestId = this.#requestIdAlloc.alloc();\n        this.#responseMap.set(requestId, { ...callbacks, type: request.type });\n        this.#send({ type: \"request\", requestId, request });\n    }\n    // The socket encountered an error.\n    #onSocketError(event) {\n        const eventMessage = event.message;\n        const message = eventMessage ?? \"WebSocket was closed due to an error\";\n        this.#setClosed(new WebSocketError(message));\n    }\n    // The socket was closed.\n    #onSocketClose(event) {\n        let message = `WebSocket was closed with code ${event.code}`;\n        if (event.reason) {\n            message += `: ${event.reason}`;\n        }\n        this.#setClosed(new WebSocketError(message));\n    }\n    // Close the client with the given error.\n    #setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        for (const callbacks of this.#openCallbacks) {\n            callbacks.errorCallback(error);\n        }\n        this.#openCallbacks.length = 0;\n        for (const [requestId, responseState] of this.#responseMap.entries()) {\n            responseState.errorCallback(error);\n            this.#requestIdAlloc.free(requestId);\n        }\n        this.#responseMap.clear();\n        this.#socket.close();\n    }\n    // We received a message from the socket.\n    #onSocketMessage(event) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        try {\n            let msg;\n            const encoding = this.#subprotocol.encoding;\n            if (encoding === \"json\") {\n                if (typeof event.data !== \"string\") {\n                    this.#socket.close(3003, \"Only text messages are accepted with JSON encoding\");\n                    this.#setClosed(new ProtoError(\"Received non-text message from server with JSON encoding\"));\n                    return;\n                }\n                msg = readJsonObject(JSON.parse(event.data), json_ServerMsg);\n            }\n            else if (encoding === \"protobuf\") {\n                if (!(event.data instanceof ArrayBuffer)) {\n                    this.#socket.close(3003, \"Only binary messages are accepted with Protobuf encoding\");\n                    this.#setClosed(new ProtoError(\"Received non-binary message from server with Protobuf encoding\"));\n                    return;\n                }\n                msg = readProtobufMessage(new Uint8Array(event.data), protobuf_ServerMsg);\n            }\n            else {\n                throw impossible(encoding, \"Impossible encoding\");\n            }\n            this.#handleMsg(msg);\n        }\n        catch (e) {\n            this.#socket.close(3007, \"Could not handle message\");\n            this.#setClosed(e);\n        }\n    }\n    // Handle a message from the server.\n    #handleMsg(msg) {\n        if (msg.type === \"none\") {\n            throw new ProtoError(\"Received an unrecognized ServerMsg\");\n        }\n        else if (msg.type === \"hello_ok\" || msg.type === \"hello_error\") {\n            if (this.#recvdHello) {\n                throw new ProtoError(\"Received a duplicated hello response\");\n            }\n            this.#recvdHello = true;\n            if (msg.type === \"hello_error\") {\n                throw errorFromProto(msg.error);\n            }\n            return;\n        }\n        else if (!this.#recvdHello) {\n            throw new ProtoError(\"Received a non-hello message before a hello response\");\n        }\n        if (msg.type === \"response_ok\") {\n            const requestId = msg.requestId;\n            const responseState = this.#responseMap.get(requestId);\n            this.#responseMap.delete(requestId);\n            if (responseState === undefined) {\n                throw new ProtoError(\"Received unexpected OK response\");\n            }\n            this.#requestIdAlloc.free(requestId);\n            try {\n                if (responseState.type !== msg.response.type) {\n                    console.dir({ responseState, msg });\n                    throw new ProtoError(\"Received unexpected type of response\");\n                }\n                responseState.responseCallback(msg.response);\n            }\n            catch (e) {\n                responseState.errorCallback(e);\n                throw e;\n            }\n        }\n        else if (msg.type === \"response_error\") {\n            const requestId = msg.requestId;\n            const responseState = this.#responseMap.get(requestId);\n            this.#responseMap.delete(requestId);\n            if (responseState === undefined) {\n                throw new ProtoError(\"Received unexpected error response\");\n            }\n            this.#requestIdAlloc.free(requestId);\n            responseState.errorCallback(errorFromProto(msg.error));\n        }\n        else {\n            throw impossible(msg, \"Impossible ServerMsg type\");\n        }\n    }\n    /** Open a {@link WsStream}, a stream for executing SQL statements. */\n    openStream() {\n        return WsStream.open(this);\n    }\n    /** Cache a SQL text on the server. This requires protocol version 2 or higher. */\n    storeSql(sql) {\n        this._ensureVersion(2, \"storeSql()\");\n        const sqlId = this.#sqlIdAlloc.alloc();\n        const sqlObj = new Sql(this, sqlId);\n        const responseCallback = () => undefined;\n        const errorCallback = (e) => sqlObj._setClosed(e);\n        const request = { type: \"store_sql\", sqlId, sql };\n        this._sendRequest(request, { responseCallback, errorCallback });\n        return sqlObj;\n    }\n    /** @private */\n    _closeSql(sqlId) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        const responseCallback = () => this.#sqlIdAlloc.free(sqlId);\n        const errorCallback = (e) => this.#setClosed(e);\n        const request = { type: \"close_sql\", sqlId };\n        this._sendRequest(request, { responseCallback, errorCallback });\n    }\n    /** Close the client and the WebSocket. */\n    close() {\n        this.#setClosed(new ClientError(\"Client was manually closed\"));\n    }\n    /** True if the client is closed. */\n    get closed() {\n        return this.#closed !== undefined;\n    }\n}\n","const _fetch = fetch;\nconst _Request = Request;\nconst _Headers = Headers;\nexport {\n    _fetch as fetch,\n    _Request as Request,\n    _Headers as Headers,\n};\n","// queueMicrotask() ponyfill\n// https://github.com/libsql/libsql-client-ts/issues/47\nlet _queueMicrotask;\nif (typeof queueMicrotask !== \"undefined\") {\n    _queueMicrotask = queueMicrotask;\n}\nelse {\n    const resolved = Promise.resolve();\n    _queueMicrotask = (callback) => {\n        resolved.then(callback);\n    };\n}\nexport { _queueMicrotask as queueMicrotask };\n","export class ByteQueue {\n    #array;\n    #shiftPos;\n    #pushPos;\n    constructor(initialCap) {\n        this.#array = new Uint8Array(new ArrayBuffer(initialCap));\n        this.#shiftPos = 0;\n        this.#pushPos = 0;\n    }\n    get length() {\n        return this.#pushPos - this.#shiftPos;\n    }\n    data() {\n        return this.#array.slice(this.#shiftPos, this.#pushPos);\n    }\n    push(chunk) {\n        this.#ensurePush(chunk.byteLength);\n        this.#array.set(chunk, this.#pushPos);\n        this.#pushPos += chunk.byteLength;\n    }\n    #ensurePush(pushLength) {\n        if (this.#pushPos + pushLength <= this.#array.byteLength) {\n            return;\n        }\n        const filledLength = this.#pushPos - this.#shiftPos;\n        if (filledLength + pushLength <= this.#array.byteLength &&\n            2 * this.#pushPos >= this.#array.byteLength) {\n            this.#array.copyWithin(0, this.#shiftPos, this.#pushPos);\n        }\n        else {\n            let newCap = this.#array.byteLength;\n            do {\n                newCap *= 2;\n            } while (filledLength + pushLength > newCap);\n            const newArray = new Uint8Array(new ArrayBuffer(newCap));\n            newArray.set(this.#array.slice(this.#shiftPos, this.#pushPos), 0);\n            this.#array = newArray;\n        }\n        this.#pushPos = filledLength;\n        this.#shiftPos = 0;\n    }\n    shift(length) {\n        this.#shiftPos += length;\n    }\n}\n","import { ProtoError } from \"../errors.js\";\nimport * as d from \"../encoding/json/decode.js\";\nimport { Error, StmtResult, BatchResult, DescribeResult } from \"../shared/json_decode.js\";\nexport function PipelineRespBody(obj) {\n    const baton = d.stringOpt(obj[\"baton\"]);\n    const baseUrl = d.stringOpt(obj[\"base_url\"]);\n    const results = d.arrayObjectsMap(obj[\"results\"], StreamResult);\n    return { baton, baseUrl, results };\n}\nfunction StreamResult(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"ok\") {\n        const response = StreamResponse(d.object(obj[\"response\"]));\n        return { type: \"ok\", response };\n    }\n    else if (type === \"error\") {\n        const error = Error(d.object(obj[\"error\"]));\n        return { type: \"error\", error };\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of StreamResult\");\n    }\n}\nfunction StreamResponse(obj) {\n    const type = d.string(obj[\"type\"]);\n    if (type === \"close\") {\n        return { type: \"close\" };\n    }\n    else if (type === \"execute\") {\n        const result = StmtResult(d.object(obj[\"result\"]));\n        return { type: \"execute\", result };\n    }\n    else if (type === \"batch\") {\n        const result = BatchResult(d.object(obj[\"result\"]));\n        return { type: \"batch\", result };\n    }\n    else if (type === \"sequence\") {\n        return { type: \"sequence\" };\n    }\n    else if (type === \"describe\") {\n        const result = DescribeResult(d.object(obj[\"result\"]));\n        return { type: \"describe\", result };\n    }\n    else if (type === \"store_sql\") {\n        return { type: \"store_sql\" };\n    }\n    else if (type === \"close_sql\") {\n        return { type: \"close_sql\" };\n    }\n    else if (type === \"get_autocommit\") {\n        const isAutocommit = d.boolean(obj[\"is_autocommit\"]);\n        return { type: \"get_autocommit\", isAutocommit };\n    }\n    else {\n        throw new ProtoError(\"Unexpected type of StreamResponse\");\n    }\n}\nexport function CursorRespBody(obj) {\n    const baton = d.stringOpt(obj[\"baton\"]);\n    const baseUrl = d.stringOpt(obj[\"base_url\"]);\n    return { baton, baseUrl };\n}\n","import { Error, StmtResult, BatchResult, DescribeResult } from \"../shared/protobuf_decode.js\";\nexport const PipelineRespBody = {\n    default() { return { baton: undefined, baseUrl: undefined, results: [] }; },\n    1(r, msg) { msg.baton = r.string(); },\n    2(r, msg) { msg.baseUrl = r.string(); },\n    3(r, msg) { msg.results.push(r.message(StreamResult)); },\n};\nconst StreamResult = {\n    default() { return { type: \"none\" }; },\n    1(r) { return { type: \"ok\", response: r.message(StreamResponse) }; },\n    2(r) { return { type: \"error\", error: r.message(Error) }; },\n};\nconst StreamResponse = {\n    default() { return { type: \"none\" }; },\n    1(r) { return { type: \"close\" }; },\n    2(r) { return r.message(ExecuteStreamResp); },\n    3(r) { return r.message(BatchStreamResp); },\n    4(r) { return { type: \"sequence\" }; },\n    5(r) { return r.message(DescribeStreamResp); },\n    6(r) { return { type: \"store_sql\" }; },\n    7(r) { return { type: \"close_sql\" }; },\n    8(r) { return r.message(GetAutocommitStreamResp); },\n};\nconst ExecuteStreamResp = {\n    default() { return { type: \"execute\", result: StmtResult.default() }; },\n    1(r, msg) { msg.result = r.message(StmtResult); },\n};\nconst BatchStreamResp = {\n    default() { return { type: \"batch\", result: BatchResult.default() }; },\n    1(r, msg) { msg.result = r.message(BatchResult); },\n};\nconst DescribeStreamResp = {\n    default() { return { type: \"describe\", result: DescribeResult.default() }; },\n    1(r, msg) { msg.result = r.message(DescribeResult); },\n};\nconst GetAutocommitStreamResp = {\n    default() { return { type: \"get_autocommit\", isAutocommit: false }; },\n    1(r, msg) { msg.isAutocommit = r.bool(); },\n};\nexport const CursorRespBody = {\n    default() { return { baton: undefined, baseUrl: undefined }; },\n    1(r, msg) { msg.baton = r.string(); },\n    2(r, msg) { msg.baseUrl = r.string(); },\n};\n","import { ByteQueue } from \"../byte_queue.js\";\nimport { Cursor } from \"../cursor.js\";\nimport * as jsond from \"../encoding/json/decode.js\";\nimport * as protobufd from \"../encoding/protobuf/decode.js\";\nimport { ClientError, ClosedError, ProtoError, InternalError } from \"../errors.js\";\nimport { impossible } from \"../util.js\";\nimport { CursorRespBody as json_CursorRespBody } from \"./json_decode.js\";\nimport { CursorRespBody as protobuf_CursorRespBody } from \"./protobuf_decode.js\";\nimport { CursorEntry as json_CursorEntry } from \"../shared/json_decode.js\";\nimport { CursorEntry as protobuf_CursorEntry } from \"../shared/protobuf_decode.js\";\nexport class HttpCursor extends Cursor {\n    #stream;\n    #encoding;\n    #reader;\n    #queue;\n    #closed;\n    #done;\n    /** @private */\n    constructor(stream, encoding) {\n        super();\n        this.#stream = stream;\n        this.#encoding = encoding;\n        this.#reader = undefined;\n        this.#queue = new ByteQueue(16 * 1024);\n        this.#closed = undefined;\n        this.#done = false;\n    }\n    async open(response) {\n        if (response.body === null) {\n            throw new ProtoError(\"No response body for cursor request\");\n        }\n        this.#reader = response.body.getReader();\n        const respBody = await this.#nextItem(json_CursorRespBody, protobuf_CursorRespBody);\n        if (respBody === undefined) {\n            throw new ProtoError(\"Empty response to cursor request\");\n        }\n        return respBody;\n    }\n    /** Fetch the next entry from the cursor. */\n    next() {\n        return this.#nextItem(json_CursorEntry, protobuf_CursorEntry);\n    }\n    /** Close the cursor. */\n    close() {\n        this._setClosed(new ClientError(\"Cursor was manually closed\"));\n    }\n    /** @private */\n    _setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        this.#stream._cursorClosed(this);\n        if (this.#reader !== undefined) {\n            this.#reader.cancel();\n        }\n    }\n    /** True if the cursor is closed. */\n    get closed() {\n        return this.#closed !== undefined;\n    }\n    async #nextItem(jsonFun, protobufDef) {\n        for (;;) {\n            if (this.#done) {\n                return undefined;\n            }\n            else if (this.#closed !== undefined) {\n                throw new ClosedError(\"Cursor is closed\", this.#closed);\n            }\n            if (this.#encoding === \"json\") {\n                const jsonData = this.#parseItemJson();\n                if (jsonData !== undefined) {\n                    const jsonText = new TextDecoder().decode(jsonData);\n                    const jsonValue = JSON.parse(jsonText);\n                    return jsond.readJsonObject(jsonValue, jsonFun);\n                }\n            }\n            else if (this.#encoding === \"protobuf\") {\n                const protobufData = this.#parseItemProtobuf();\n                if (protobufData !== undefined) {\n                    return protobufd.readProtobufMessage(protobufData, protobufDef);\n                }\n            }\n            else {\n                throw impossible(this.#encoding, \"Impossible encoding\");\n            }\n            if (this.#reader === undefined) {\n                throw new InternalError(\"Attempted to read from HTTP cursor before it was opened\");\n            }\n            const { value, done } = await this.#reader.read();\n            if (done && this.#queue.length === 0) {\n                this.#done = true;\n            }\n            else if (done) {\n                throw new ProtoError(\"Unexpected end of cursor stream\");\n            }\n            else {\n                this.#queue.push(value);\n            }\n        }\n    }\n    #parseItemJson() {\n        const data = this.#queue.data();\n        const newlineByte = 10;\n        const newlinePos = data.indexOf(newlineByte);\n        if (newlinePos < 0) {\n            return undefined;\n        }\n        const jsonData = data.slice(0, newlinePos);\n        this.#queue.shift(newlinePos + 1);\n        return jsonData;\n    }\n    #parseItemProtobuf() {\n        const data = this.#queue.data();\n        let varintValue = 0;\n        let varintLength = 0;\n        for (;;) {\n            if (varintLength >= data.byteLength) {\n                return undefined;\n            }\n            const byte = data[varintLength];\n            varintValue |= (byte & 0x7f) << (7 * varintLength);\n            varintLength += 1;\n            if (!(byte & 0x80)) {\n                break;\n            }\n        }\n        if (data.byteLength < varintLength + varintValue) {\n            return undefined;\n        }\n        const protobufData = data.slice(varintLength, varintLength + varintValue);\n        this.#queue.shift(varintLength + varintValue);\n        return protobufData;\n    }\n}\n","import { Stmt, Batch } from \"../shared/json_encode.js\";\nimport { impossible } from \"../util.js\";\nexport function PipelineReqBody(w, msg) {\n    if (msg.baton !== undefined) {\n        w.string(\"baton\", msg.baton);\n    }\n    w.arrayObjects(\"requests\", msg.requests, StreamRequest);\n}\nfunction StreamRequest(w, msg) {\n    w.stringRaw(\"type\", msg.type);\n    if (msg.type === \"close\") {\n        // do nothing\n    }\n    else if (msg.type === \"execute\") {\n        w.object(\"stmt\", msg.stmt, Stmt);\n    }\n    else if (msg.type === \"batch\") {\n        w.object(\"batch\", msg.batch, Batch);\n    }\n    else if (msg.type === \"sequence\") {\n        if (msg.sql !== undefined) {\n            w.string(\"sql\", msg.sql);\n        }\n        if (msg.sqlId !== undefined) {\n            w.number(\"sql_id\", msg.sqlId);\n        }\n    }\n    else if (msg.type === \"describe\") {\n        if (msg.sql !== undefined) {\n            w.string(\"sql\", msg.sql);\n        }\n        if (msg.sqlId !== undefined) {\n            w.number(\"sql_id\", msg.sqlId);\n        }\n    }\n    else if (msg.type === \"store_sql\") {\n        w.number(\"sql_id\", msg.sqlId);\n        w.string(\"sql\", msg.sql);\n    }\n    else if (msg.type === \"close_sql\") {\n        w.number(\"sql_id\", msg.sqlId);\n    }\n    else if (msg.type === \"get_autocommit\") {\n        // do nothing\n    }\n    else {\n        throw impossible(msg, \"Impossible type of StreamRequest\");\n    }\n}\nexport function CursorReqBody(w, msg) {\n    if (msg.baton !== undefined) {\n        w.string(\"baton\", msg.baton);\n    }\n    w.object(\"batch\", msg.batch, Batch);\n}\n","import { Stmt, Batch } from \"../shared/protobuf_encode.js\";\nimport { impossible } from \"../util.js\";\nexport function PipelineReqBody(w, msg) {\n    if (msg.baton !== undefined) {\n        w.string(1, msg.baton);\n    }\n    for (const req of msg.requests) {\n        w.message(2, req, StreamRequest);\n    }\n}\nfunction StreamRequest(w, msg) {\n    if (msg.type === \"close\") {\n        w.message(1, msg, CloseStreamReq);\n    }\n    else if (msg.type === \"execute\") {\n        w.message(2, msg, ExecuteStreamReq);\n    }\n    else if (msg.type === \"batch\") {\n        w.message(3, msg, BatchStreamReq);\n    }\n    else if (msg.type === \"sequence\") {\n        w.message(4, msg, SequenceStreamReq);\n    }\n    else if (msg.type === \"describe\") {\n        w.message(5, msg, DescribeStreamReq);\n    }\n    else if (msg.type === \"store_sql\") {\n        w.message(6, msg, StoreSqlStreamReq);\n    }\n    else if (msg.type === \"close_sql\") {\n        w.message(7, msg, CloseSqlStreamReq);\n    }\n    else if (msg.type === \"get_autocommit\") {\n        w.message(8, msg, GetAutocommitStreamReq);\n    }\n    else {\n        throw impossible(msg, \"Impossible type of StreamRequest\");\n    }\n}\nfunction CloseStreamReq(_w, _msg) {\n}\nfunction ExecuteStreamReq(w, msg) {\n    w.message(1, msg.stmt, Stmt);\n}\nfunction BatchStreamReq(w, msg) {\n    w.message(1, msg.batch, Batch);\n}\nfunction SequenceStreamReq(w, msg) {\n    if (msg.sql !== undefined) {\n        w.string(1, msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.int32(2, msg.sqlId);\n    }\n}\nfunction DescribeStreamReq(w, msg) {\n    if (msg.sql !== undefined) {\n        w.string(1, msg.sql);\n    }\n    if (msg.sqlId !== undefined) {\n        w.int32(2, msg.sqlId);\n    }\n}\nfunction StoreSqlStreamReq(w, msg) {\n    w.int32(1, msg.sqlId);\n    w.string(2, msg.sql);\n}\nfunction CloseSqlStreamReq(w, msg) {\n    w.int32(1, msg.sqlId);\n}\nfunction GetAutocommitStreamReq(_w, _msg) {\n}\nexport function CursorReqBody(w, msg) {\n    if (msg.baton !== undefined) {\n        w.string(1, msg.baton);\n    }\n    w.message(2, msg.batch, Batch);\n}\n","import { Request, Headers } from \"@libsql/isomorphic-fetch\";\nimport { ClientError, HttpServerError, ProtocolVersionError, ProtoError, ClosedError, InternalError, } from \"../errors.js\";\nimport { readJsonObject, writeJsonObject, readProtobufMessage, writeProtobufMessage, } from \"../encoding/index.js\";\nimport { IdAlloc } from \"../id_alloc.js\";\nimport { Queue } from \"../queue.js\";\nimport { queueMicrotask } from \"../queue_microtask.js\";\nimport { errorFromProto } from \"../result.js\";\nimport { Sql } from \"../sql.js\";\nimport { Stream } from \"../stream.js\";\nimport { impossible } from \"../util.js\";\nimport { HttpCursor } from \"./cursor.js\";\nimport { PipelineReqBody as json_PipelineReqBody } from \"./json_encode.js\";\nimport { PipelineReqBody as protobuf_PipelineReqBody } from \"./protobuf_encode.js\";\nimport { CursorReqBody as json_CursorReqBody } from \"./json_encode.js\";\nimport { CursorReqBody as protobuf_CursorReqBody } from \"./protobuf_encode.js\";\nimport { PipelineRespBody as json_PipelineRespBody } from \"./json_decode.js\";\nimport { PipelineRespBody as protobuf_PipelineRespBody } from \"./protobuf_decode.js\";\nexport class HttpStream extends Stream {\n    #client;\n    #baseUrl;\n    #jwt;\n    #fetch;\n    #baton;\n    #queue;\n    #flushing;\n    #cursor;\n    #closing;\n    #closeQueued;\n    #closed;\n    #sqlIdAlloc;\n    /** @private */\n    constructor(client, baseUrl, jwt, customFetch) {\n        super(client.intMode);\n        this.#client = client;\n        this.#baseUrl = baseUrl.toString();\n        this.#jwt = jwt;\n        this.#fetch = customFetch;\n        this.#baton = undefined;\n        this.#queue = new Queue();\n        this.#flushing = false;\n        this.#closing = false;\n        this.#closeQueued = false;\n        this.#closed = undefined;\n        this.#sqlIdAlloc = new IdAlloc();\n    }\n    /** Get the {@link HttpClient} object that this stream belongs to. */\n    client() {\n        return this.#client;\n    }\n    /** @private */\n    _sqlOwner() {\n        return this;\n    }\n    /** Cache a SQL text on the server. */\n    storeSql(sql) {\n        const sqlId = this.#sqlIdAlloc.alloc();\n        this.#sendStreamRequest({ type: \"store_sql\", sqlId, sql }).then(() => undefined, (error) => this._setClosed(error));\n        return new Sql(this, sqlId);\n    }\n    /** @private */\n    _closeSql(sqlId) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#sendStreamRequest({ type: \"close_sql\", sqlId }).then(() => this.#sqlIdAlloc.free(sqlId), (error) => this._setClosed(error));\n    }\n    /** @private */\n    _execute(stmt) {\n        return this.#sendStreamRequest({ type: \"execute\", stmt }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _batch(batch) {\n        return this.#sendStreamRequest({ type: \"batch\", batch }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _describe(protoSql) {\n        return this.#sendStreamRequest({\n            type: \"describe\",\n            sql: protoSql.sql,\n            sqlId: protoSql.sqlId\n        }).then((response) => {\n            return response.result;\n        });\n    }\n    /** @private */\n    _sequence(protoSql) {\n        return this.#sendStreamRequest({\n            type: \"sequence\",\n            sql: protoSql.sql,\n            sqlId: protoSql.sqlId,\n        }).then((_response) => {\n            return undefined;\n        });\n    }\n    /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an\n     * explicit transaction). This requires protocol version 3 or higher.\n     */\n    getAutocommit() {\n        this.#client._ensureVersion(3, \"getAutocommit()\");\n        return this.#sendStreamRequest({\n            type: \"get_autocommit\",\n        }).then((response) => {\n            return response.isAutocommit;\n        });\n    }\n    #sendStreamRequest(request) {\n        return new Promise((responseCallback, errorCallback) => {\n            this.#pushToQueue({ type: \"pipeline\", request, responseCallback, errorCallback });\n        });\n    }\n    /** @private */\n    _openCursor(batch) {\n        return new Promise((cursorCallback, errorCallback) => {\n            this.#pushToQueue({ type: \"cursor\", batch, cursorCallback, errorCallback });\n        });\n    }\n    /** @private */\n    _cursorClosed(cursor) {\n        if (cursor !== this.#cursor) {\n            throw new InternalError(\"Cursor was closed, but it was not associated with the stream\");\n        }\n        this.#cursor = undefined;\n        queueMicrotask(() => this.#flushQueue());\n    }\n    /** Immediately close the stream. */\n    close() {\n        this._setClosed(new ClientError(\"Stream was manually closed\"));\n    }\n    /** Gracefully close the stream. */\n    closeGracefully() {\n        this.#closing = true;\n        queueMicrotask(() => this.#flushQueue());\n    }\n    /** True if the stream is closed. */\n    get closed() {\n        return this.#closed !== undefined || this.#closing;\n    }\n    /** @private */\n    _setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        if (this.#cursor !== undefined) {\n            this.#cursor._setClosed(error);\n        }\n        this.#client._streamClosed(this);\n        for (;;) {\n            const entry = this.#queue.shift();\n            if (entry !== undefined) {\n                entry.errorCallback(error);\n            }\n            else {\n                break;\n            }\n        }\n        if ((this.#baton !== undefined || this.#flushing) && !this.#closeQueued) {\n            this.#queue.push({\n                type: \"pipeline\",\n                request: { type: \"close\" },\n                responseCallback: () => undefined,\n                errorCallback: () => undefined,\n            });\n            this.#closeQueued = true;\n            queueMicrotask(() => this.#flushQueue());\n        }\n    }\n    #pushToQueue(entry) {\n        if (this.#closed !== undefined) {\n            throw new ClosedError(\"Stream is closed\", this.#closed);\n        }\n        else if (this.#closing) {\n            throw new ClosedError(\"Stream is closing\", undefined);\n        }\n        else {\n            this.#queue.push(entry);\n            queueMicrotask(() => this.#flushQueue());\n        }\n    }\n    #flushQueue() {\n        if (this.#flushing || this.#cursor !== undefined) {\n            return;\n        }\n        if (this.#closing && this.#queue.length === 0) {\n            this._setClosed(new ClientError(\"Stream was gracefully closed\"));\n            return;\n        }\n        const endpoint = this.#client._endpoint;\n        if (endpoint === undefined) {\n            this.#client._endpointPromise.then(() => this.#flushQueue(), (error) => this._setClosed(error));\n            return;\n        }\n        const firstEntry = this.#queue.shift();\n        if (firstEntry === undefined) {\n            return;\n        }\n        else if (firstEntry.type === \"pipeline\") {\n            const pipeline = [firstEntry];\n            for (;;) {\n                const entry = this.#queue.first();\n                if (entry !== undefined && entry.type === \"pipeline\") {\n                    pipeline.push(entry);\n                    this.#queue.shift();\n                }\n                else if (entry === undefined && this.#closing && !this.#closeQueued) {\n                    pipeline.push({\n                        type: \"pipeline\",\n                        request: { type: \"close\" },\n                        responseCallback: () => undefined,\n                        errorCallback: () => undefined,\n                    });\n                    this.#closeQueued = true;\n                    break;\n                }\n                else {\n                    break;\n                }\n            }\n            this.#flushPipeline(endpoint, pipeline);\n        }\n        else if (firstEntry.type === \"cursor\") {\n            this.#flushCursor(endpoint, firstEntry);\n        }\n        else {\n            throw impossible(firstEntry, \"Impossible type of QueueEntry\");\n        }\n    }\n    #flushPipeline(endpoint, pipeline) {\n        this.#flush(() => this.#createPipelineRequest(pipeline, endpoint), (resp) => decodePipelineResponse(resp, endpoint.encoding), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (respBody) => handlePipelineResponse(pipeline, respBody), (error) => pipeline.forEach((entry) => entry.errorCallback(error)));\n    }\n    #flushCursor(endpoint, entry) {\n        const cursor = new HttpCursor(this, endpoint.encoding);\n        this.#cursor = cursor;\n        this.#flush(() => this.#createCursorRequest(entry, endpoint), (resp) => cursor.open(resp), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (_respBody) => entry.cursorCallback(cursor), (error) => entry.errorCallback(error));\n    }\n    #flush(createRequest, decodeResponse, getBaton, getBaseUrl, handleResponse, handleError) {\n        let promise;\n        try {\n            const request = createRequest();\n            const fetch = this.#fetch;\n            promise = fetch(request);\n        }\n        catch (error) {\n            promise = Promise.reject(error);\n        }\n        this.#flushing = true;\n        promise.then((resp) => {\n            if (!resp.ok) {\n                return errorFromResponse(resp).then((error) => {\n                    throw error;\n                });\n            }\n            return decodeResponse(resp);\n        }).then((r) => {\n            this.#baton = getBaton(r);\n            this.#baseUrl = getBaseUrl(r) ?? this.#baseUrl;\n            handleResponse(r);\n        }).catch((error) => {\n            this._setClosed(error);\n            handleError(error);\n        }).finally(() => {\n            this.#flushing = false;\n            this.#flushQueue();\n        });\n    }\n    #createPipelineRequest(pipeline, endpoint) {\n        return this.#createRequest(new URL(endpoint.pipelinePath, this.#baseUrl), {\n            baton: this.#baton,\n            requests: pipeline.map((entry) => entry.request),\n        }, endpoint.encoding, json_PipelineReqBody, protobuf_PipelineReqBody);\n    }\n    #createCursorRequest(entry, endpoint) {\n        if (endpoint.cursorPath === undefined) {\n            throw new ProtocolVersionError(\"Cursors are supported only on protocol version 3 and higher, \" +\n                `but the HTTP server only supports version ${endpoint.version}.`);\n        }\n        return this.#createRequest(new URL(endpoint.cursorPath, this.#baseUrl), {\n            baton: this.#baton,\n            batch: entry.batch,\n        }, endpoint.encoding, json_CursorReqBody, protobuf_CursorReqBody);\n    }\n    #createRequest(url, reqBody, encoding, jsonFun, protobufFun) {\n        let bodyData;\n        let contentType;\n        if (encoding === \"json\") {\n            bodyData = writeJsonObject(reqBody, jsonFun);\n            contentType = \"application/json\";\n        }\n        else if (encoding === \"protobuf\") {\n            bodyData = writeProtobufMessage(reqBody, protobufFun);\n            contentType = \"application/x-protobuf\";\n        }\n        else {\n            throw impossible(encoding, \"Impossible encoding\");\n        }\n        const headers = new Headers();\n        headers.set(\"content-type\", contentType);\n        if (this.#jwt !== undefined) {\n            headers.set(\"authorization\", `Bearer ${this.#jwt}`);\n        }\n        return new Request(url.toString(), { method: \"POST\", headers, body: bodyData });\n    }\n}\nfunction handlePipelineResponse(pipeline, respBody) {\n    if (respBody.results.length !== pipeline.length) {\n        throw new ProtoError(\"Server returned unexpected number of pipeline results\");\n    }\n    for (let i = 0; i < pipeline.length; ++i) {\n        const result = respBody.results[i];\n        const entry = pipeline[i];\n        if (result.type === \"ok\") {\n            if (result.response.type !== entry.request.type) {\n                throw new ProtoError(\"Received unexpected type of response\");\n            }\n            entry.responseCallback(result.response);\n        }\n        else if (result.type === \"error\") {\n            entry.errorCallback(errorFromProto(result.error));\n        }\n        else if (result.type === \"none\") {\n            throw new ProtoError(\"Received unrecognized type of StreamResult\");\n        }\n        else {\n            throw impossible(result, \"Received impossible type of StreamResult\");\n        }\n    }\n}\nasync function decodePipelineResponse(resp, encoding) {\n    if (encoding === \"json\") {\n        const respJson = await resp.json();\n        return readJsonObject(respJson, json_PipelineRespBody);\n    }\n    if (encoding === \"protobuf\") {\n        const respData = await resp.arrayBuffer();\n        return readProtobufMessage(new Uint8Array(respData), protobuf_PipelineRespBody);\n    }\n    await resp.body?.cancel();\n    throw impossible(encoding, \"Impossible encoding\");\n}\nasync function errorFromResponse(resp) {\n    const respType = resp.headers.get(\"content-type\") ?? \"text/plain\";\n    let message = `Server returned HTTP status ${resp.status}`;\n    if (respType === \"application/json\") {\n        const respBody = await resp.json();\n        if (\"message\" in respBody) {\n            return errorFromProto(respBody);\n        }\n        return new HttpServerError(message, resp.status);\n    }\n    if (respType === \"text/plain\") {\n        const respBody = (await resp.text()).trim();\n        if (respBody !== \"\") {\n            message += `: ${respBody}`;\n        }\n        return new HttpServerError(message, resp.status);\n    }\n    await resp.body?.cancel();\n    return new HttpServerError(message, resp.status);\n}\n","import { fetch, Request } from \"@libsql/isomorphic-fetch\";\nimport { Client } from \"../client.js\";\nimport { ClientError, ClosedError, ProtocolVersionError } from \"../errors.js\";\nimport { HttpStream } from \"./stream.js\";\nexport const checkEndpoints = [\n    {\n        versionPath: \"v3-protobuf\",\n        pipelinePath: \"v3-protobuf/pipeline\",\n        cursorPath: \"v3-protobuf/cursor\",\n        version: 3,\n        encoding: \"protobuf\",\n    },\n    /*\n    {\n        versionPath: \"v3\",\n        pipelinePath: \"v3/pipeline\",\n        cursorPath: \"v3/cursor\",\n        version: 3,\n        encoding: \"json\",\n    },\n    */\n];\nconst fallbackEndpoint = {\n    versionPath: \"v2\",\n    pipelinePath: \"v2/pipeline\",\n    cursorPath: undefined,\n    version: 2,\n    encoding: \"json\",\n};\n/** A client for the Hrana protocol over HTTP. */\nexport class HttpClient extends Client {\n    #url;\n    #jwt;\n    #fetch;\n    #closed;\n    #streams;\n    /** @private */\n    _endpointPromise;\n    /** @private */\n    _endpoint;\n    /** @private */\n    constructor(url, jwt, customFetch, protocolVersion = 2) {\n        super();\n        this.#url = url;\n        this.#jwt = jwt;\n        this.#fetch = customFetch ?? fetch;\n        this.#closed = undefined;\n        this.#streams = new Set();\n        if (protocolVersion == 3) {\n            this._endpointPromise = findEndpoint(this.#fetch, this.#url);\n            this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => this.#setClosed(error));\n        }\n        else {\n            this._endpointPromise = Promise.resolve(fallbackEndpoint);\n            this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => this.#setClosed(error));\n        }\n    }\n    /** Get the protocol version supported by the server. */\n    async getVersion() {\n        if (this._endpoint !== undefined) {\n            return this._endpoint.version;\n        }\n        return (await this._endpointPromise).version;\n    }\n    // Make sure that the negotiated version is at least `minVersion`.\n    /** @private */\n    _ensureVersion(minVersion, feature) {\n        if (minVersion <= fallbackEndpoint.version) {\n            return;\n        }\n        else if (this._endpoint === undefined) {\n            throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` +\n                \"but the version supported by the HTTP server is not yet known. \" +\n                \"Use Client.getVersion() to wait until the version is available.\");\n        }\n        else if (this._endpoint.version < minVersion) {\n            throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` +\n                `but the HTTP server only supports version ${this._endpoint.version}.`);\n        }\n    }\n    /** Open a {@link HttpStream}, a stream for executing SQL statements. */\n    openStream() {\n        if (this.#closed !== undefined) {\n            throw new ClosedError(\"Client is closed\", this.#closed);\n        }\n        const stream = new HttpStream(this, this.#url, this.#jwt, this.#fetch);\n        this.#streams.add(stream);\n        return stream;\n    }\n    /** @private */\n    _streamClosed(stream) {\n        this.#streams.delete(stream);\n    }\n    /** Close the client and all its streams. */\n    close() {\n        this.#setClosed(new ClientError(\"Client was manually closed\"));\n    }\n    /** True if the client is closed. */\n    get closed() {\n        return this.#closed !== undefined;\n    }\n    #setClosed(error) {\n        if (this.#closed !== undefined) {\n            return;\n        }\n        this.#closed = error;\n        for (const stream of Array.from(this.#streams)) {\n            stream._setClosed(new ClosedError(\"Client was closed\", error));\n        }\n    }\n}\nasync function findEndpoint(customFetch, clientUrl) {\n    const fetch = customFetch;\n    for (const endpoint of checkEndpoints) {\n        const url = new URL(endpoint.versionPath, clientUrl);\n        const request = new Request(url.toString(), { method: \"GET\" });\n        const response = await fetch(request);\n        await response.arrayBuffer();\n        if (response.ok) {\n            return endpoint;\n        }\n    }\n    return fallbackEndpoint;\n}\n","import { WebSocket } from \"@libsql/isomorphic-ws\";\nimport { subprotocolsV2, subprotocolsV3 } from \"./ws/client.js\";\nimport { WebSocketUnsupportedError } from \"./errors.js\";\nimport { HttpClient } from \"./http/client.js\";\nimport { WsClient } from \"./ws/client.js\";\nexport { WebSocket } from \"@libsql/isomorphic-ws\";\nexport { fetch, Request, Headers } from \"@libsql/isomorphic-fetch\";\nexport { Client } from \"./client.js\";\nexport * from \"./errors.js\";\nexport { Batch, BatchStep, BatchCond } from \"./batch.js\";\nexport { parseLibsqlUrl } from \"./libsql_url.js\";\nexport { Sql } from \"./sql.js\";\nexport { Stmt } from \"./stmt.js\";\nexport { Stream } from \"./stream.js\";\nexport { HttpClient } from \"./http/client.js\";\nexport { HttpStream } from \"./http/stream.js\";\nexport { WsClient } from \"./ws/client.js\";\nexport { WsStream } from \"./ws/stream.js\";\n/** Open a Hrana client over WebSocket connected to the given `url`. */\nexport function openWs(url, jwt, protocolVersion = 2) {\n    if (typeof WebSocket === \"undefined\") {\n        throw new WebSocketUnsupportedError(\"WebSockets are not supported in this environment\");\n    }\n    var subprotocols = undefined;\n    if (protocolVersion == 3) {\n        subprotocols = Array.from(subprotocolsV3.keys());\n    }\n    else {\n        subprotocols = Array.from(subprotocolsV2.keys());\n    }\n    const socket = new WebSocket(url, subprotocols);\n    return new WsClient(socket, jwt);\n}\n/** Open a Hrana client over HTTP connected to the given `url`.\n *\n * If the `customFetch` argument is passed and not `undefined`, it is used in place of the `fetch` function\n * from `@libsql/isomorphic-fetch`. This function is always called with a `Request` object from\n * `@libsql/isomorphic-fetch`.\n */\nexport function openHttp(url, jwt, customFetch, protocolVersion = 2) {\n    return new HttpClient(url instanceof URL ? url : new URL(url), jwt, customFetch, protocolVersion);\n}\n","import * as hrana from \"@libsql/hrana-client\";\nimport { LibsqlError } from \"@libsql/core/api\";\nimport { transactionModeToBegin, ResultSetImpl } from \"@libsql/core/util\";\nexport class HranaTransaction {\n    #mode;\n    #version;\n    // Promise that is resolved when the BEGIN statement completes, or `undefined` if we haven't executed the\n    // BEGIN statement yet.\n    #started;\n    /** @private */\n    constructor(mode, version) {\n        this.#mode = mode;\n        this.#version = version;\n        this.#started = undefined;\n    }\n    execute(stmt) {\n        return this.batch([stmt]).then((results) => results[0]);\n    }\n    async batch(stmts) {\n        const stream = this._getStream();\n        if (stream.closed) {\n            throw new LibsqlError(\"Cannot execute statements because the transaction is closed\", \"TRANSACTION_CLOSED\");\n        }\n        try {\n            const hranaStmts = stmts.map(stmtToHrana);\n            let rowsPromises;\n            if (this.#started === undefined) {\n                // The transaction hasn't started yet, so we need to send the BEGIN statement in a batch with\n                // `hranaStmts`.\n                this._getSqlCache().apply(hranaStmts);\n                const batch = stream.batch(this.#version >= 3);\n                const beginStep = batch.step();\n                const beginPromise = beginStep.run(transactionModeToBegin(this.#mode));\n                // Execute the `hranaStmts` only if the BEGIN succeeded, to make sure that we don't execute it\n                // outside of a transaction.\n                let lastStep = beginStep;\n                rowsPromises = hranaStmts.map((hranaStmt) => {\n                    const stmtStep = batch\n                        .step()\n                        .condition(hrana.BatchCond.ok(lastStep));\n                    if (this.#version >= 3) {\n                        // If the Hrana version supports it, make sure that we are still in a transaction\n                        stmtStep.condition(hrana.BatchCond.not(hrana.BatchCond.isAutocommit(batch)));\n                    }\n                    const rowsPromise = stmtStep.query(hranaStmt);\n                    rowsPromise.catch(() => undefined); // silence Node warning\n                    lastStep = stmtStep;\n                    return rowsPromise;\n                });\n                // `this.#started` is resolved successfully only if the batch and the BEGIN statement inside\n                // of the batch are both successful.\n                this.#started = batch\n                    .execute()\n                    .then(() => beginPromise)\n                    .then(() => undefined);\n                try {\n                    await this.#started;\n                }\n                catch (e) {\n                    // If the BEGIN failed, the transaction is unusable and we must close it. However, if the\n                    // BEGIN suceeds and `hranaStmts` fail, the transaction is _not_ closed.\n                    this.close();\n                    throw e;\n                }\n            }\n            else {\n                if (this.#version < 3) {\n                    // The transaction has started, so we must wait until the BEGIN statement completed to make\n                    // sure that we don't execute `hranaStmts` outside of a transaction.\n                    await this.#started;\n                }\n                else {\n                    // The transaction has started, but we will use `hrana.BatchCond.isAutocommit()` to make\n                    // sure that we don't execute `hranaStmts` outside of a transaction, so we don't have to\n                    // wait for `this.#started`\n                }\n                this._getSqlCache().apply(hranaStmts);\n                const batch = stream.batch(this.#version >= 3);\n                let lastStep = undefined;\n                rowsPromises = hranaStmts.map((hranaStmt) => {\n                    const stmtStep = batch.step();\n                    if (lastStep !== undefined) {\n                        stmtStep.condition(hrana.BatchCond.ok(lastStep));\n                    }\n                    if (this.#version >= 3) {\n                        stmtStep.condition(hrana.BatchCond.not(hrana.BatchCond.isAutocommit(batch)));\n                    }\n                    const rowsPromise = stmtStep.query(hranaStmt);\n                    rowsPromise.catch(() => undefined); // silence Node warning\n                    lastStep = stmtStep;\n                    return rowsPromise;\n                });\n                await batch.execute();\n            }\n            const resultSets = [];\n            for (const rowsPromise of rowsPromises) {\n                const rows = await rowsPromise;\n                if (rows === undefined) {\n                    throw new LibsqlError(\"Statement in a transaction was not executed, \" +\n                        \"probably because the transaction has been rolled back\", \"TRANSACTION_CLOSED\");\n                }\n                resultSets.push(resultSetFromHrana(rows));\n            }\n            return resultSets;\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n    }\n    async executeMultiple(sql) {\n        const stream = this._getStream();\n        if (stream.closed) {\n            throw new LibsqlError(\"Cannot execute statements because the transaction is closed\", \"TRANSACTION_CLOSED\");\n        }\n        try {\n            if (this.#started === undefined) {\n                // If the transaction hasn't started yet, start it now\n                this.#started = stream\n                    .run(transactionModeToBegin(this.#mode))\n                    .then(() => undefined);\n                try {\n                    await this.#started;\n                }\n                catch (e) {\n                    this.close();\n                    throw e;\n                }\n            }\n            else {\n                // Wait until the transaction has started\n                await this.#started;\n            }\n            await stream.sequence(sql);\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n    }\n    async rollback() {\n        try {\n            const stream = this._getStream();\n            if (stream.closed) {\n                return;\n            }\n            if (this.#started !== undefined) {\n                // We don't have to wait for the BEGIN statement to complete. If the BEGIN fails, we will\n                // execute a ROLLBACK outside of an active transaction, which should be harmless.\n            }\n            else {\n                // We did nothing in the transaction, so there is nothing to rollback.\n                return;\n            }\n            // Pipeline the ROLLBACK statement and the stream close.\n            const promise = stream.run(\"ROLLBACK\").catch((e) => {\n                throw mapHranaError(e);\n            });\n            stream.closeGracefully();\n            await promise;\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n        finally {\n            // `this.close()` may close the `hrana.Client`, which aborts all pending stream requests, so we\n            // must call it _after_ we receive the ROLLBACK response.\n            // Also note that the current stream should already be closed, but we need to call `this.close()`\n            // anyway, because it may need to do more cleanup.\n            this.close();\n        }\n    }\n    async commit() {\n        // (this method is analogous to `rollback()`)\n        try {\n            const stream = this._getStream();\n            if (stream.closed) {\n                throw new LibsqlError(\"Cannot commit the transaction because it is already closed\", \"TRANSACTION_CLOSED\");\n            }\n            if (this.#started !== undefined) {\n                // Make sure to execute the COMMIT only if the BEGIN was successful.\n                await this.#started;\n            }\n            else {\n                return;\n            }\n            const promise = stream.run(\"COMMIT\").catch((e) => {\n                throw mapHranaError(e);\n            });\n            stream.closeGracefully();\n            await promise;\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n        finally {\n            this.close();\n        }\n    }\n}\nexport async function executeHranaBatch(mode, version, batch, hranaStmts, disableForeignKeys = false) {\n    if (disableForeignKeys) {\n        batch.step().run(\"PRAGMA foreign_keys=off\");\n    }\n    const beginStep = batch.step();\n    const beginPromise = beginStep.run(transactionModeToBegin(mode));\n    let lastStep = beginStep;\n    const stmtPromises = hranaStmts.map((hranaStmt) => {\n        const stmtStep = batch.step().condition(hrana.BatchCond.ok(lastStep));\n        if (version >= 3) {\n            stmtStep.condition(hrana.BatchCond.not(hrana.BatchCond.isAutocommit(batch)));\n        }\n        const stmtPromise = stmtStep.query(hranaStmt);\n        lastStep = stmtStep;\n        return stmtPromise;\n    });\n    const commitStep = batch.step().condition(hrana.BatchCond.ok(lastStep));\n    if (version >= 3) {\n        commitStep.condition(hrana.BatchCond.not(hrana.BatchCond.isAutocommit(batch)));\n    }\n    const commitPromise = commitStep.run(\"COMMIT\");\n    const rollbackStep = batch\n        .step()\n        .condition(hrana.BatchCond.not(hrana.BatchCond.ok(commitStep)));\n    rollbackStep.run(\"ROLLBACK\").catch((_) => undefined);\n    if (disableForeignKeys) {\n        batch.step().run(\"PRAGMA foreign_keys=on\");\n    }\n    await batch.execute();\n    const resultSets = [];\n    await beginPromise;\n    for (const stmtPromise of stmtPromises) {\n        const hranaRows = await stmtPromise;\n        if (hranaRows === undefined) {\n            throw new LibsqlError(\"Statement in a batch was not executed, probably because the transaction has been rolled back\", \"TRANSACTION_CLOSED\");\n        }\n        resultSets.push(resultSetFromHrana(hranaRows));\n    }\n    await commitPromise;\n    return resultSets;\n}\nexport function stmtToHrana(stmt) {\n    let sql;\n    let args;\n    if (Array.isArray(stmt)) {\n        [sql, args] = stmt;\n    }\n    else if (typeof stmt === \"string\") {\n        sql = stmt;\n    }\n    else {\n        sql = stmt.sql;\n        args = stmt.args;\n    }\n    const hranaStmt = new hrana.Stmt(sql);\n    if (args) {\n        if (Array.isArray(args)) {\n            hranaStmt.bindIndexes(args);\n        }\n        else {\n            for (const [key, value] of Object.entries(args)) {\n                hranaStmt.bindName(key, value);\n            }\n        }\n    }\n    return hranaStmt;\n}\nexport function resultSetFromHrana(hranaRows) {\n    const columns = hranaRows.columnNames.map((c) => c ?? \"\");\n    const columnTypes = hranaRows.columnDecltypes.map((c) => c ?? \"\");\n    const rows = hranaRows.rows;\n    const rowsAffected = hranaRows.affectedRowCount;\n    const lastInsertRowid = hranaRows.lastInsertRowid !== undefined\n        ? hranaRows.lastInsertRowid\n        : undefined;\n    return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);\n}\nexport function mapHranaError(e) {\n    if (e instanceof hrana.ClientError) {\n        const code = mapHranaErrorCode(e);\n        return new LibsqlError(e.message, code, undefined, e);\n    }\n    return e;\n}\nfunction mapHranaErrorCode(e) {\n    if (e instanceof hrana.ResponseError && e.code !== undefined) {\n        return e.code;\n    }\n    else if (e instanceof hrana.ProtoError) {\n        return \"HRANA_PROTO_ERROR\";\n    }\n    else if (e instanceof hrana.ClosedError) {\n        return e.cause instanceof hrana.ClientError\n            ? mapHranaErrorCode(e.cause)\n            : \"HRANA_CLOSED_ERROR\";\n    }\n    else if (e instanceof hrana.WebSocketError) {\n        return \"HRANA_WEBSOCKET_ERROR\";\n    }\n    else if (e instanceof hrana.HttpServerError) {\n        return \"SERVER_ERROR\";\n    }\n    else if (e instanceof hrana.ProtocolVersionError) {\n        return \"PROTOCOL_VERSION_ERROR\";\n    }\n    else if (e instanceof hrana.InternalError) {\n        return \"INTERNAL_ERROR\";\n    }\n    else {\n        return \"UNKNOWN\";\n    }\n}\n","export class SqlCache {\n    #owner;\n    #sqls;\n    capacity;\n    constructor(owner, capacity) {\n        this.#owner = owner;\n        this.#sqls = new Lru();\n        this.capacity = capacity;\n    }\n    // Replaces SQL strings with cached `hrana.Sql` objects in the statements in `hranaStmts`. After this\n    // function returns, we guarantee that all `hranaStmts` refer to valid (not closed) `hrana.Sql` objects,\n    // but _we may invalidate any other `hrana.Sql` objects_ (by closing them, thus removing them from the\n    // server).\n    //\n    // In practice, this means that after calling this function, you can use the statements only up to the\n    // first `await`, because concurrent code may also use the cache and invalidate those statements.\n    apply(hranaStmts) {\n        if (this.capacity <= 0) {\n            return;\n        }\n        const usedSqlObjs = new Set();\n        for (const hranaStmt of hranaStmts) {\n            if (typeof hranaStmt.sql !== \"string\") {\n                continue;\n            }\n            const sqlText = hranaStmt.sql;\n            // Stored SQL cannot exceed 5kb.\n            // https://github.com/tursodatabase/libsql/blob/e9d637e051685f92b0da43849507b5ef4232fbeb/libsql-server/src/hrana/http/request.rs#L10\n            if (sqlText.length >= 5000) {\n                continue;\n            }\n            let sqlObj = this.#sqls.get(sqlText);\n            if (sqlObj === undefined) {\n                while (this.#sqls.size + 1 > this.capacity) {\n                    const [evictSqlText, evictSqlObj] = this.#sqls.peekLru();\n                    if (usedSqlObjs.has(evictSqlObj)) {\n                        // The SQL object that we are trying to evict is already in use in this batch, so we\n                        // must not evict and close it.\n                        break;\n                    }\n                    evictSqlObj.close();\n                    this.#sqls.delete(evictSqlText);\n                }\n                if (this.#sqls.size + 1 <= this.capacity) {\n                    sqlObj = this.#owner.storeSql(sqlText);\n                    this.#sqls.set(sqlText, sqlObj);\n                }\n            }\n            if (sqlObj !== undefined) {\n                hranaStmt.sql = sqlObj;\n                usedSqlObjs.add(sqlObj);\n            }\n        }\n    }\n}\nclass Lru {\n    // This maps keys to the cache values. The entries are ordered by their last use (entires that were used\n    // most recently are at the end).\n    #cache;\n    constructor() {\n        this.#cache = new Map();\n    }\n    get(key) {\n        const value = this.#cache.get(key);\n        if (value !== undefined) {\n            // move the entry to the back of the Map\n            this.#cache.delete(key);\n            this.#cache.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        this.#cache.set(key, value);\n    }\n    peekLru() {\n        for (const entry of this.#cache.entries()) {\n            return entry;\n        }\n        return undefined;\n    }\n    delete(key) {\n        this.#cache.delete(key);\n    }\n    get size() {\n        return this.#cache.size;\n    }\n}\n","function limiter (count) {\n  var outstanding = 0\n  var jobs = []\n\n  function remove () {\n    outstanding--\n\n    if (outstanding < count) {\n      dequeue()\n    }\n  }\n\n  function dequeue () {\n    var job = jobs.shift()\n    semaphore.queue = jobs.length\n\n    if (job) {\n      run(job.fn).then(job.resolve).catch(job.reject)\n    }\n  }\n\n  function queue (fn) {\n    return new Promise(function (resolve, reject) {\n      jobs.push({fn: fn, resolve: resolve, reject: reject})\n      semaphore.queue = jobs.length\n    })\n  }\n\n  function run (fn) {\n    outstanding++\n    try {\n      return Promise.resolve(fn()).then(function (result) {\n        remove()\n        return result\n      }, function (error) {\n        remove()\n        throw error\n      })\n    } catch (err) {\n      remove()\n      return Promise.reject(err)\n    }\n  }\n\n  var semaphore = function (fn) {\n    if (outstanding >= count) {\n      return queue(fn)\n    } else {\n      return run(fn)\n    }\n  }\n\n  return semaphore\n}\n\nfunction map (items, mapper) {\n  var failed = false\n\n  var limit = this\n\n  return Promise.all(items.map(function () {\n    var args = arguments\n    return limit(function () {\n      if (!failed) {\n        return mapper.apply(undefined, args).catch(function (e) {\n          failed = true\n          throw e\n        })\n      }\n    })\n  }))\n}\n\nfunction addExtras (fn) {\n  fn.queue = 0\n  fn.map = map\n  return fn\n}\n\nmodule.exports = function (count) {\n  if (count) {\n    return addExtras(limiter(count))\n  } else {\n    return addExtras(function (fn) {\n      return fn()\n    })\n  }\n}\n","import * as hrana from \"@libsql/hrana-client\";\nimport { LibsqlError } from \"@libsql/core/api\";\nimport { expandConfig } from \"@libsql/core/config\";\nimport { HranaTransaction, executeHranaBatch, stmtToHrana, resultSetFromHrana, mapHranaError, } from \"./hrana.js\";\nimport { SqlCache } from \"./sql_cache.js\";\nimport { encodeBaseUrl } from \"@libsql/core/uri\";\nimport { supportedUrlLink } from \"@libsql/core/util\";\nimport promiseLimit from \"promise-limit\";\nexport * from \"@libsql/core/api\";\nexport function createClient(config) {\n    return _createClient(expandConfig(config, false));\n}\n/** @private */\nexport function _createClient(config) {\n    if (config.scheme !== \"wss\" && config.scheme !== \"ws\") {\n        throw new LibsqlError('The WebSocket client supports only \"libsql:\", \"wss:\" and \"ws:\" URLs, ' +\n            `got ${JSON.stringify(config.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n    }\n    if (config.encryptionKey !== undefined) {\n        throw new LibsqlError(\"Encryption key is not supported by the remote client.\", \"ENCRYPTION_KEY_NOT_SUPPORTED\");\n    }\n    if (config.scheme === \"ws\" && config.tls) {\n        throw new LibsqlError(`A \"ws:\" URL cannot opt into TLS by using ?tls=1`, \"URL_INVALID\");\n    }\n    else if (config.scheme === \"wss\" && !config.tls) {\n        throw new LibsqlError(`A \"wss:\" URL cannot opt out of TLS by using ?tls=0`, \"URL_INVALID\");\n    }\n    const url = encodeBaseUrl(config.scheme, config.authority, config.path);\n    let client;\n    try {\n        client = hrana.openWs(url, config.authToken);\n    }\n    catch (e) {\n        if (e instanceof hrana.WebSocketUnsupportedError) {\n            const suggestedScheme = config.scheme === \"wss\" ? \"https\" : \"http\";\n            const suggestedUrl = encodeBaseUrl(suggestedScheme, config.authority, config.path);\n            throw new LibsqlError(\"This environment does not support WebSockets, please switch to the HTTP client by using \" +\n                `a \"${suggestedScheme}:\" URL (${JSON.stringify(suggestedUrl)}). ` +\n                `For more information, please read ${supportedUrlLink}`, \"WEBSOCKETS_NOT_SUPPORTED\");\n        }\n        throw mapHranaError(e);\n    }\n    return new WsClient(client, url, config.authToken, config.intMode, config.concurrency);\n}\nconst maxConnAgeMillis = 60 * 1000;\nconst sqlCacheCapacity = 100;\nexport class WsClient {\n    #url;\n    #authToken;\n    #intMode;\n    // State of the current connection. The `hrana.WsClient` inside may be closed at any moment due to an\n    // asynchronous error.\n    #connState;\n    // If defined, this is a connection that will be used in the future, once it is ready.\n    #futureConnState;\n    closed;\n    protocol;\n    #isSchemaDatabase;\n    #promiseLimitFunction;\n    /** @private */\n    constructor(client, url, authToken, intMode, concurrency) {\n        this.#url = url;\n        this.#authToken = authToken;\n        this.#intMode = intMode;\n        this.#connState = this.#openConn(client);\n        this.#futureConnState = undefined;\n        this.closed = false;\n        this.protocol = \"ws\";\n        this.#promiseLimitFunction = promiseLimit(concurrency);\n    }\n    async limit(fn) {\n        return this.#promiseLimitFunction(fn);\n    }\n    async execute(stmtOrSql, args) {\n        let stmt;\n        if (typeof stmtOrSql === \"string\") {\n            stmt = {\n                sql: stmtOrSql,\n                args: args || [],\n            };\n        }\n        else {\n            stmt = stmtOrSql;\n        }\n        return this.limit(async () => {\n            const streamState = await this.#openStream();\n            try {\n                const hranaStmt = stmtToHrana(stmt);\n                // Schedule all operations synchronously, so they will be pipelined and executed in a single\n                // network roundtrip.\n                streamState.conn.sqlCache.apply([hranaStmt]);\n                const hranaRowsPromise = streamState.stream.query(hranaStmt);\n                streamState.stream.closeGracefully();\n                const hranaRowsResult = await hranaRowsPromise;\n                return resultSetFromHrana(hranaRowsResult);\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n            finally {\n                this._closeStream(streamState);\n            }\n        });\n    }\n    async batch(stmts, mode = \"deferred\") {\n        return this.limit(async () => {\n            const streamState = await this.#openStream();\n            try {\n                const normalizedStmts = stmts.map((stmt) => {\n                    if (Array.isArray(stmt)) {\n                        return {\n                            sql: stmt[0],\n                            args: stmt[1] || [],\n                        };\n                    }\n                    return stmt;\n                });\n                const hranaStmts = normalizedStmts.map(stmtToHrana);\n                const version = await streamState.conn.client.getVersion();\n                // Schedule all operations synchronously, so they will be pipelined and executed in a single\n                // network roundtrip.\n                streamState.conn.sqlCache.apply(hranaStmts);\n                const batch = streamState.stream.batch(version >= 3);\n                const resultsPromise = executeHranaBatch(mode, version, batch, hranaStmts);\n                const results = await resultsPromise;\n                return results;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n            finally {\n                this._closeStream(streamState);\n            }\n        });\n    }\n    async migrate(stmts) {\n        return this.limit(async () => {\n            const streamState = await this.#openStream();\n            try {\n                const hranaStmts = stmts.map(stmtToHrana);\n                const version = await streamState.conn.client.getVersion();\n                // Schedule all operations synchronously, so they will be pipelined and executed in a single\n                // network roundtrip.\n                const batch = streamState.stream.batch(version >= 3);\n                const resultsPromise = executeHranaBatch(\"deferred\", version, batch, hranaStmts, true);\n                const results = await resultsPromise;\n                return results;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n            finally {\n                this._closeStream(streamState);\n            }\n        });\n    }\n    async transaction(mode = \"write\") {\n        return this.limit(async () => {\n            const streamState = await this.#openStream();\n            try {\n                const version = await streamState.conn.client.getVersion();\n                // the BEGIN statement will be batched with the first statement on the transaction to save a\n                // network roundtrip\n                return new WsTransaction(this, streamState, mode, version);\n            }\n            catch (e) {\n                this._closeStream(streamState);\n                throw mapHranaError(e);\n            }\n        });\n    }\n    async executeMultiple(sql) {\n        return this.limit(async () => {\n            const streamState = await this.#openStream();\n            try {\n                // Schedule all operations synchronously, so they will be pipelined and executed in a single\n                // network roundtrip.\n                const promise = streamState.stream.sequence(sql);\n                streamState.stream.closeGracefully();\n                await promise;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n            finally {\n                this._closeStream(streamState);\n            }\n        });\n    }\n    sync() {\n        throw new LibsqlError(\"sync not supported in ws mode\", \"SYNC_NOT_SUPPORTED\");\n    }\n    async #openStream() {\n        if (this.closed) {\n            throw new LibsqlError(\"The client is closed\", \"CLIENT_CLOSED\");\n        }\n        const now = new Date();\n        const ageMillis = now.valueOf() - this.#connState.openTime.valueOf();\n        if (ageMillis > maxConnAgeMillis &&\n            this.#futureConnState === undefined) {\n            // The existing connection is too old, let's open a new one.\n            const futureConnState = this.#openConn();\n            this.#futureConnState = futureConnState;\n            // However, if we used `futureConnState` immediately, we would introduce additional latency,\n            // because we would have to wait for the WebSocket handshake to complete, even though we may a\n            // have perfectly good existing connection in `this.#connState`!\n            //\n            // So we wait until the `hrana.Client.getVersion()` operation completes (which happens when the\n            // WebSocket hanshake completes), and only then we replace `this.#connState` with\n            // `futureConnState`, which is stored in `this.#futureConnState` in the meantime.\n            futureConnState.client.getVersion().then((_version) => {\n                if (this.#connState !== futureConnState) {\n                    // We need to close `this.#connState` before we replace it. However, it is possible\n                    // that `this.#connState` has already been replaced: see the code below.\n                    if (this.#connState.streamStates.size === 0) {\n                        this.#connState.client.close();\n                    }\n                    else {\n                        // If there are existing streams on the connection, we must not close it, because\n                        // these streams would be broken. The last stream to be closed will also close the\n                        // connection in `_closeStream()`.\n                    }\n                }\n                this.#connState = futureConnState;\n                this.#futureConnState = undefined;\n            }, (_e) => {\n                // If the new connection could not be established, let's just ignore the error and keep\n                // using the existing connection.\n                this.#futureConnState = undefined;\n            });\n        }\n        if (this.#connState.client.closed) {\n            // An error happened on this connection and it has been closed. Let's try to seamlessly reconnect.\n            try {\n                if (this.#futureConnState !== undefined) {\n                    // We are already in the process of opening a new connection, so let's just use it\n                    // immediately.\n                    this.#connState = this.#futureConnState;\n                }\n                else {\n                    this.#connState = this.#openConn();\n                }\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        }\n        const connState = this.#connState;\n        try {\n            // Now we wait for the WebSocket handshake to complete (if it hasn't completed yet). Note that\n            // this does not increase latency, because any messages that we would send on the WebSocket before\n            // the handshake would be queued until the handshake is completed anyway.\n            if (connState.useSqlCache === undefined) {\n                connState.useSqlCache =\n                    (await connState.client.getVersion()) >= 2;\n                if (connState.useSqlCache) {\n                    connState.sqlCache.capacity = sqlCacheCapacity;\n                }\n            }\n            const stream = connState.client.openStream();\n            stream.intMode = this.#intMode;\n            const streamState = { conn: connState, stream };\n            connState.streamStates.add(streamState);\n            return streamState;\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n    }\n    #openConn(client) {\n        try {\n            client ??= hrana.openWs(this.#url, this.#authToken);\n            return {\n                client,\n                useSqlCache: undefined,\n                sqlCache: new SqlCache(client, 0),\n                openTime: new Date(),\n                streamStates: new Set(),\n            };\n        }\n        catch (e) {\n            throw mapHranaError(e);\n        }\n    }\n    async reconnect() {\n        try {\n            for (const st of Array.from(this.#connState.streamStates)) {\n                try {\n                    st.stream.close();\n                }\n                catch { }\n            }\n            this.#connState.client.close();\n        }\n        catch { }\n        if (this.#futureConnState) {\n            try {\n                this.#futureConnState.client.close();\n            }\n            catch { }\n            this.#futureConnState = undefined;\n        }\n        const next = this.#openConn();\n        const version = await next.client.getVersion();\n        next.useSqlCache = version >= 2;\n        if (next.useSqlCache) {\n            next.sqlCache.capacity = sqlCacheCapacity;\n        }\n        this.#connState = next;\n        this.closed = false;\n    }\n    _closeStream(streamState) {\n        streamState.stream.close();\n        const connState = streamState.conn;\n        connState.streamStates.delete(streamState);\n        if (connState.streamStates.size === 0 &&\n            connState !== this.#connState) {\n            // We are not using this connection anymore and this is the last stream that was using it, so we\n            // must close it now.\n            connState.client.close();\n        }\n    }\n    close() {\n        this.#connState.client.close();\n        this.closed = true;\n        if (this.#futureConnState) {\n            try {\n                this.#futureConnState.client.close();\n            }\n            catch { }\n            this.#futureConnState = undefined;\n        }\n        this.closed = true;\n    }\n}\nexport class WsTransaction extends HranaTransaction {\n    #client;\n    #streamState;\n    /** @private */\n    constructor(client, state, mode, version) {\n        super(mode, version);\n        this.#client = client;\n        this.#streamState = state;\n    }\n    /** @private */\n    _getStream() {\n        return this.#streamState.stream;\n    }\n    /** @private */\n    _getSqlCache() {\n        return this.#streamState.conn.sqlCache;\n    }\n    close() {\n        this.#client._closeStream(this.#streamState);\n    }\n    get closed() {\n        return this.#streamState.stream.closed;\n    }\n}\n","import * as hrana from \"@libsql/hrana-client\";\nimport { LibsqlError } from \"@libsql/core/api\";\nimport { expandConfig } from \"@libsql/core/config\";\nimport { HranaTransaction, executeHranaBatch, stmtToHrana, resultSetFromHrana, mapHranaError, } from \"./hrana.js\";\nimport { SqlCache } from \"./sql_cache.js\";\nimport { encodeBaseUrl } from \"@libsql/core/uri\";\nimport { supportedUrlLink } from \"@libsql/core/util\";\nimport promiseLimit from \"promise-limit\";\nexport * from \"@libsql/core/api\";\nexport function createClient(config) {\n    return _createClient(expandConfig(config, true));\n}\n/** @private */\nexport function _createClient(config) {\n    if (config.scheme !== \"https\" && config.scheme !== \"http\") {\n        throw new LibsqlError('The HTTP client supports only \"libsql:\", \"https:\" and \"http:\" URLs, ' +\n            `got ${JSON.stringify(config.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n    }\n    if (config.encryptionKey !== undefined) {\n        throw new LibsqlError(\"Encryption key is not supported by the remote client.\", \"ENCRYPTION_KEY_NOT_SUPPORTED\");\n    }\n    if (config.scheme === \"http\" && config.tls) {\n        throw new LibsqlError(`A \"http:\" URL cannot opt into TLS by using ?tls=1`, \"URL_INVALID\");\n    }\n    else if (config.scheme === \"https\" && !config.tls) {\n        throw new LibsqlError(`A \"https:\" URL cannot opt out of TLS by using ?tls=0`, \"URL_INVALID\");\n    }\n    const url = encodeBaseUrl(config.scheme, config.authority, config.path);\n    return new HttpClient(url, config.authToken, config.intMode, config.fetch, config.concurrency);\n}\nconst sqlCacheCapacity = 30;\nexport class HttpClient {\n    #client;\n    protocol;\n    #url;\n    #intMode;\n    #customFetch;\n    #concurrency;\n    #authToken;\n    #promiseLimitFunction;\n    /** @private */\n    constructor(url, authToken, intMode, customFetch, concurrency) {\n        this.#url = url;\n        this.#authToken = authToken;\n        this.#intMode = intMode;\n        this.#customFetch = customFetch;\n        this.#concurrency = concurrency;\n        this.#client = hrana.openHttp(this.#url, this.#authToken, this.#customFetch);\n        this.#client.intMode = this.#intMode;\n        this.protocol = \"http\";\n        this.#promiseLimitFunction = promiseLimit(this.#concurrency);\n    }\n    async limit(fn) {\n        return this.#promiseLimitFunction(fn);\n    }\n    async execute(stmtOrSql, args) {\n        let stmt;\n        if (typeof stmtOrSql === \"string\") {\n            stmt = {\n                sql: stmtOrSql,\n                args: args || [],\n            };\n        }\n        else {\n            stmt = stmtOrSql;\n        }\n        return this.limit(async () => {\n            try {\n                const hranaStmt = stmtToHrana(stmt);\n                // Pipeline all operations, so `hrana.HttpClient` can open the stream, execute the statement and\n                // close the stream in a single HTTP request.\n                let rowsPromise;\n                const stream = this.#client.openStream();\n                try {\n                    rowsPromise = stream.query(hranaStmt);\n                }\n                finally {\n                    stream.closeGracefully();\n                }\n                const rowsResult = await rowsPromise;\n                return resultSetFromHrana(rowsResult);\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        });\n    }\n    async batch(stmts, mode = \"deferred\") {\n        return this.limit(async () => {\n            try {\n                const normalizedStmts = stmts.map((stmt) => {\n                    if (Array.isArray(stmt)) {\n                        return {\n                            sql: stmt[0],\n                            args: stmt[1] || [],\n                        };\n                    }\n                    return stmt;\n                });\n                const hranaStmts = normalizedStmts.map(stmtToHrana);\n                const version = await this.#client.getVersion();\n                // Pipeline all operations, so `hrana.HttpClient` can open the stream, execute the batch and\n                // close the stream in a single HTTP request.\n                let resultsPromise;\n                const stream = this.#client.openStream();\n                try {\n                    // It makes sense to use a SQL cache even for a single batch, because it may contain the same\n                    // statement repeated multiple times.\n                    const sqlCache = new SqlCache(stream, sqlCacheCapacity);\n                    sqlCache.apply(hranaStmts);\n                    // TODO: we do not use a cursor here, because it would cause three roundtrips:\n                    // 1. pipeline request to store SQL texts\n                    // 2. cursor request\n                    // 3. pipeline request to close the stream\n                    const batch = stream.batch(false);\n                    resultsPromise = executeHranaBatch(mode, version, batch, hranaStmts);\n                }\n                finally {\n                    stream.closeGracefully();\n                }\n                const results = await resultsPromise;\n                return results;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        });\n    }\n    async migrate(stmts) {\n        return this.limit(async () => {\n            try {\n                const hranaStmts = stmts.map(stmtToHrana);\n                const version = await this.#client.getVersion();\n                // Pipeline all operations, so `hrana.HttpClient` can open the stream, execute the batch and\n                // close the stream in a single HTTP request.\n                let resultsPromise;\n                const stream = this.#client.openStream();\n                try {\n                    const batch = stream.batch(false);\n                    resultsPromise = executeHranaBatch(\"deferred\", version, batch, hranaStmts, true);\n                }\n                finally {\n                    stream.closeGracefully();\n                }\n                const results = await resultsPromise;\n                return results;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        });\n    }\n    async transaction(mode = \"write\") {\n        return this.limit(async () => {\n            try {\n                const version = await this.#client.getVersion();\n                return new HttpTransaction(this.#client.openStream(), mode, version);\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        });\n    }\n    async executeMultiple(sql) {\n        return this.limit(async () => {\n            try {\n                // Pipeline all operations, so `hrana.HttpClient` can open the stream, execute the sequence and\n                // close the stream in a single HTTP request.\n                let promise;\n                const stream = this.#client.openStream();\n                try {\n                    promise = stream.sequence(sql);\n                }\n                finally {\n                    stream.closeGracefully();\n                }\n                await promise;\n            }\n            catch (e) {\n                throw mapHranaError(e);\n            }\n        });\n    }\n    sync() {\n        throw new LibsqlError(\"sync not supported in http mode\", \"SYNC_NOT_SUPPORTED\");\n    }\n    close() {\n        this.#client.close();\n    }\n    async reconnect() {\n        try {\n            if (!this.closed) {\n                // Abort in-flight ops and free resources\n                this.#client.close();\n            }\n        }\n        finally {\n            // Recreate the underlying hrana client\n            this.#client = hrana.openHttp(this.#url, this.#authToken, this.#customFetch);\n            this.#client.intMode = this.#intMode;\n        }\n    }\n    get closed() {\n        return this.#client.closed;\n    }\n}\nexport class HttpTransaction extends HranaTransaction {\n    #stream;\n    #sqlCache;\n    /** @private */\n    constructor(stream, mode, version) {\n        super(mode, version);\n        this.#stream = stream;\n        this.#sqlCache = new SqlCache(stream, sqlCacheCapacity);\n    }\n    /** @private */\n    _getStream() {\n        return this.#stream;\n    }\n    /** @private */\n    _getSqlCache() {\n        return this.#sqlCache;\n    }\n    close() {\n        this.#stream.close();\n    }\n    get closed() {\n        return this.#stream.closed;\n    }\n}\n","import { LibsqlError } from \"@libsql/core/api\";\nimport { expandConfig } from \"@libsql/core/config\";\nimport { supportedUrlLink } from \"@libsql/core/util\";\nimport { _createClient as _createWsClient } from \"./ws.js\";\nimport { _createClient as _createHttpClient } from \"./http.js\";\nexport * from \"@libsql/core/api\";\nexport function createClient(config) {\n    return _createClient(expandConfig(config, true));\n}\n/** @private */\nexport function _createClient(config) {\n    if (config.scheme === \"ws\" || config.scheme === \"wss\") {\n        return _createWsClient(config);\n    }\n    else if (config.scheme === \"http\" || config.scheme === \"https\") {\n        return _createHttpClient(config);\n    }\n    else {\n        throw new LibsqlError('The client that uses Web standard APIs supports only \"libsql:\", \"wss:\", \"ws:\", \"https:\" and \"http:\" URLs, ' +\n            `got ${JSON.stringify(config.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n    }\n}\n","/**\n* @vue/shared v3.5.26\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return ((str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  });\n};\nconst camelizeRE = /-\\w/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nfunction genCacheKey(source, options) {\n  return source + JSON.stringify(\n    options,\n    (_, val) => typeof val === \"function\" ? val.toString() : val\n  );\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `CACHED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  if (!styles) return \"\";\n  if (isString(styles)) return styles;\n  let ret = \"\";\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nfunction normalizeCssVarValue(value) {\n  if (value == null) {\n    return \"initial\";\n  }\n  if (typeof value === \"string\") {\n    return value === \"\" ? \" \" : value;\n  }\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(\n        \"[Vue warn] Invalid value used for CSS binding. Expected a string or a finite number but received:\",\n        value\n      );\n    }\n  }\n  return String(value);\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, cssVarNameEscapeSymbolsRE, def, escapeHtml, escapeHtmlComment, extend, genCacheKey, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeCssVarValue, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","/**\n* @vue/reactivity v3.5.26\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  // TODO isolatedDeclarations \"__v_skip\"\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    /**\n     * @internal\n     */\n    this.__v_skip = true;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = /* @__PURE__ */ Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = /* @__PURE__ */ Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = /* @__PURE__ */ Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nfunction toWrapped(target, item) {\n  if (isReadonly(target)) {\n    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);\n  }\n  return toReactive(item);\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toWrapped(this, value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(\n      this,\n      \"filter\",\n      fn,\n      thisArg,\n      (v) => v.map((item) => toWrapped(this, item)),\n      arguments\n    );\n  },\n  find(fn, thisArg) {\n    return apply(\n      this,\n      \"find\",\n      fn,\n      thisArg,\n      (item) => toWrapped(this, item),\n      arguments\n    );\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(\n      this,\n      \"findLast\",\n      fn,\n      thisArg,\n      (item) => toWrapped(this, item),\n      arguments\n    );\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimization required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", (item) => toWrapped(this, item));\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (!result.done) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      const value = targetIsArray && isIntegerKey(key) ? res : res.value;\n      return isReadonly2 && isObject(value) ? readonly(value) : value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn(\n              `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n              target[key]\n            );\n          }\n          return true;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return target.size;\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    this._raw = toRaw(_object);\n    let shallow = true;\n    let obj = _object;\n    if (!isArray(_object) || !isIntegerKey(String(_key))) {\n      do {\n        shallow = !isProxy(obj) || isShallow(obj);\n      } while (shallow && (obj = obj[\"__v_raw\"]));\n    }\n    this._shallow = shallow;\n  }\n  get value() {\n    let val = this._object[this._key];\n    if (this._shallow) {\n      val = unref(val);\n    }\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    if (this._shallow && isRef(this._raw[this._key])) {\n      const nestedRef = this._object[this._key];\n      if (isRef(nestedRef)) {\n        nestedRef.value = newVal;\n        return;\n      }\n    }\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(this._raw, this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  return new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          oldValue = newValue;\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Map();\n  if ((seen.get(value) || 0) >= depth) {\n    return value;\n  }\n  seen.set(value, depth);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"mappings":"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"}